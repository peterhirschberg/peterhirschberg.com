/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/adventure.ts":
/*!**************************!*\
  !*** ./src/adventure.ts ***!
  \**************************/
/*! exports provided: Adventure_Run */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Adventure_Run\", function() { return Adventure_Run; });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/constants.ts\");\n/* harmony import */ var _platform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./platform */ \"./src/platform.ts\");\n//\r\n// Adventure: Revisited\r\n//\r\n// C++ Version Copyright (c) 2006 Peter Hirschberg\r\n//\r\n// Typescript Version Copyright (c) 2019 Peter Hirschberg\r\n//\r\n// This was pretty much a 1:1 port of my C++ version.\r\n// As such this code is very \"C style\" and I apologize for that. :-)\r\n//\r\n// peter@peterhirschberg.com\r\n// http://peterhirschberg.com\r\n//\r\n// Big thanks to Joel D. Park and others for annotating the original Adventure decompiled assembly code.\r\n// I relied heavily and deliberately on that commented code.\r\n//\r\n// Original Adventure(c) game Copyright (c) 1980 ATARI, INC.\r\n// Any trademarks referenced herein are the property of their respective holders.\r\n// \r\n// Original game written by Warren Robinett. Warren, you rock.\r\n//\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Some consts\r\nvar PLAYFIELD_HRES = 20; // 40 with 2nd half mirrored/repeated\r\nvar PLAYFIELD_VRES = 20;\r\nvar CLOCKS_HSYNC = 2;\r\nvar CLOCKS_VSYNC = 4;\r\nvar ROOMFLAG_NONE = 0x00;\r\nvar ROOMFLAG_MIRROR = 0x01; // bit 0 - 1 if graphics are mirrored, 0 for reversed\r\nvar ROOMFLAG_LEFTTHINWALL = 0x02; // bit 1 - 1 for left thin wall\r\nvar ROOMFLAG_RIGHTTHINWALL = 0x04; // bit 2 - 1 for right thin wall\r\nvar OBJECT_RIGHTWALL = -5;\r\nvar OBJECT_LEFTWALL = -4;\r\nvar OBJECT_SURROUND = -3;\r\nvar OBJECT_BALL = -2;\r\nvar OBJECT_NONE = -1;\r\nvar OBJECT_PORT1 = 0;\r\nvar OBJECT_PORT2 = 1;\r\nvar OBJECT_PORT3 = 2;\r\nvar OBJECT_NAME = 3;\r\nvar OBJECT_NUMBER = 4;\r\nvar OBJECT_REDDRAGON = 5;\r\nvar OBJECT_YELLOWDRAGON = 6;\r\nvar OBJECT_GREENDRAGON = 7;\r\nvar OBJECT_SWORD = 8;\r\nvar OBJECT_BRIDGE = 9;\r\nvar OBJECT_YELLOWKEY = 10;\r\nvar OBJECT_WHITEKEY = 11;\r\nvar OBJECT_BLACKKEY = 12;\r\nvar OBJECT_BAT = 13;\r\nvar OBJECT_DOT = 14;\r\nvar OBJECT_CHALISE = 15;\r\nvar OBJECT_MAGNET = 16;\r\n// local game state vars\r\nvar joystick = { left: false, up: false, right: false, down: false, fire: false };\r\nvar switchSelect, switchReset;\r\nvar MAX_OBJECTS = 16; // Should be plenty\r\nvar showObjectFlicker = true; // True if accurate object flicker is desired\r\nvar maxDisplayableObjects = 2; // The 2600 only has 2 Player (sprite) objects. Accuracy will be compromised if this is changed!\r\nvar displayListIndex = 0;\r\n// finite state machine values\r\nvar GAMESTATE_GAMESELECT = 0;\r\nvar GAMESTATE_ACTIVE_1 = 1;\r\nvar GAMESTATE_ACTIVE_2 = 2;\r\nvar GAMESTATE_ACTIVE_3 = 3;\r\nvar GAMESTATE_WIN = 4;\r\nvar gameState = GAMESTATE_GAMESELECT; // finite state machine\r\nfunction ISGAMEACTIVE() { return gameState == GAMESTATE_ACTIVE_1 || gameState == GAMESTATE_ACTIVE_2 || gameState == GAMESTATE_ACTIVE_3; }\r\n// Difficulty switches\r\n// When the left difficulty switch is in the B position, the Dragons will hesitate before they bite you.\r\n// If the right difficulty switch is in the B position all Dragons will run from the sword.\r\nvar DIFFICULTY_A = 0;\r\nvar DIFFICULTY_B = 1;\r\nvar gameDifficultyLeft = DIFFICULTY_B; // 2600 left difficulty switch\r\nvar gameDifficultyRight = DIFFICULTY_B; // 2600 right difficulty switch\r\nvar gameLevel = 0; // current game level (1,2,3 - zero justified)\r\nvar displayedRoomIndex = 0; // index of current (displayed) room\r\nvar batFedUpTimer = 0xff;\r\n// Color flash vars\r\nvar winFlashTimer = 0;\r\nvar flashColorHue = 0;\r\nvar flashColorLum = 0;\r\n// Color lookup table (RGB)\r\nvar colorTable = [\r\n    { r: 0x00, g: 0x00, b: 0x00 },\r\n    { r: 0xcd, g: 0xcd, b: 0xcd },\r\n    { r: 0xff, g: 0xff, b: 0xff },\r\n    { r: 0xFF, g: 0xD8, b: 0x4C },\r\n    { r: 0xff, g: 0x98, b: 0x2c },\r\n    { r: 0xfa, g: 0x52, b: 0x55 },\r\n    { r: 0xA2, g: 0x51, b: 0xD9 },\r\n    { r: 0x6b, g: 0x64, b: 0xff },\r\n    { r: 0x55, g: 0xb6, b: 0xff },\r\n    { r: 0x61, g: 0xd0, b: 0x70 },\r\n    { r: 0x21, g: 0xd9, b: 0x1b },\r\n    { r: 0x86, g: 0xd9, b: 0x22 },\r\n    { r: 0xa1, g: 0xb0, b: 0x34 },\r\n    { r: 0xd5, g: 0xb5, b: 0x43 },\r\n    { r: 0xa8, g: 0xfc, b: 0x41 } // flash (0xcb)\r\n];\r\nvar COLOR_BLACK = 0;\r\nvar COLOR_LTGRAY = 1;\r\nvar COLOR_WHITE = 2;\r\nvar COLOR_YELLOW = 3;\r\nvar COLOR_ORANGE = 4;\r\nvar COLOR_RED = 5;\r\nvar COLOR_PURPLE = 6;\r\nvar COLOR_BLUE = 7;\r\nvar COLOR_LTCYAN = 8;\r\nvar COLOR_CYAN = 9;\r\nvar COLOR_DKGREEN = 10;\r\nvar COLOR_LIMEGREEN = 11;\r\nvar COLOR_OLIVEGREEN = 12;\r\nvar COLOR_TAN = 13;\r\nvar COLOR_FLASH = 14;\r\n// \r\n// Room graphics\r\n//\r\n// Left of Name Room                                                                                                 \r\nvar roomGfxLeftOfName = [\r\n    0xF0, 0xFF, 0xFF,\r\n    0x00, 0x00, 0x00,\r\n    0x00, 0x00, 0x00,\r\n    0x00, 0x00, 0x00,\r\n    0x00, 0x00, 0x00,\r\n    0x00, 0x00, 0x00,\r\n    0xF0, 0xFF, 0x0F // XXXXXXXXXXXXXXXX        RRRRRRRRRRRRRRRRRRRR\r\n];\r\n// Below Yellow Castle                                                                                               \r\nvar roomGfxBelowYellowCastle = [\r\n    0xF0, 0xFF, 0x0F,\r\n    0x00, 0x00, 0x00,\r\n    0x00, 0x00, 0x00,\r\n    0x00, 0x00, 0x00,\r\n    0x00, 0x00, 0x00,\r\n    0x00, 0x00, 0x00,\r\n    0xF0, 0xFF, 0xFF // XXXXXXXXXXXXXXXXXXXXRRRRRRRRRRRRRRRRRRRRRRRR                                  \r\n];\r\n// Side Corridor                                                                                                     \r\nvar roomGfxSideCorridor = [\r\n    0xF0, 0xFF, 0x0F,\r\n    0x00, 0x00, 0x00,\r\n    0x00, 0x00, 0x00,\r\n    0x00, 0x00, 0x00,\r\n    0x00, 0x00, 0x00,\r\n    0x00, 0x00, 0x00,\r\n    0xF0, 0xFF, 0x0F // XXXXXXXXXXXXXXXX        RRRRRRRRRRRRRRRR                                      \r\n];\r\n// Number Room Definition                                                                                            \r\nvar roomGfxNumberRoom = [\r\n    0xF0, 0xFF, 0xFF,\r\n    0x30, 0x00, 0x00,\r\n    0x30, 0x00, 0x00,\r\n    0x30, 0x00, 0x00,\r\n    0x30, 0x00, 0x00,\r\n    0x30, 0x00, 0x00,\r\n    0xF0, 0xFF, 0x0F // XXXXXXXXXXXXXXXXXXXXRRRRRRRRRRRRRRRRRRRR                                      \r\n];\r\n// `                                                                                                     \r\nvar roomGfxTwoExitRoom = [\r\n    0xF0, 0xFF, 0x0F,\r\n    0x30, 0x00, 0x00,\r\n    0x30, 0x00, 0x00,\r\n    0x30, 0x00, 0x00,\r\n    0x30, 0x00, 0x00,\r\n    0x30, 0x00, 0x00,\r\n    0xF0, 0xFF, 0x0F // XXXXXXXXXXXXXXXX        RRRRRRRRRRRRRRRR                                      \r\n];\r\n// Top of Blue Maze                                                                                                  \r\nvar roomGfxBlueMazeTop = [\r\n    0xF0, 0xFF, 0x0F,\r\n    0x00, 0x0C, 0x0C,\r\n    0xF0, 0x0C, 0x3C,\r\n    0xF0, 0x0C, 0x00,\r\n    0xF0, 0xFF, 0x3F,\r\n    0x00, 0x30, 0x30,\r\n    0xF0, 0x33, 0x3F // XXXX  XX  XXXXXXXX    RRRRRRRR  RR  RRRR                                      \r\n];\r\n// Blue Maze #1                                                                                                      \r\nvar roomGfxBlueMaze1 = [\r\n    0xF0, 0xFF, 0xFF,\r\n    0x00, 0x00, 0x00,\r\n    0xF0, 0xFC, 0xFF,\r\n    0xF0, 0x00, 0xC0,\r\n    0xF0, 0x3F, 0xCF,\r\n    0x00, 0x30, 0xCC,\r\n    0xF0, 0xF3, 0xCC // XXXXXXXX  XX  XX  XXRR  RR  RR  RRRRRRRR                                      \r\n];\r\n// Bottom of Blue Maze                                                                                               \r\nvar roomGfxBlueMazeBottom = [\r\n    0xF0, 0xF3, 0x0C,\r\n    0x00, 0x30, 0x0C,\r\n    0xF0, 0x3F, 0x0F,\r\n    0xF0, 0x00, 0x00,\r\n    0xF0, 0xF0, 0x00,\r\n    0x00, 0x30, 0x00,\r\n    0xF0, 0xFF, 0xFF // XXXXXXXXXXXXXXXXXXXXRRRRRRRRRRRRRRRRRRRR                                      \r\n];\r\n// Center of Blue Maze                                                                                               \r\nvar roomGfxBlueMazeCenter = [\r\n    0xF0, 0x33, 0x3F,\r\n    0x00, 0x30, 0x3C,\r\n    0xF0, 0xFF, 0x3C,\r\n    0x00, 0x03, 0x3C,\r\n    0xF0, 0x33, 0x3C,\r\n    0x00, 0x33, 0x0C,\r\n    0xF0, 0xF3, 0x0C // XXXXXXXX  XX  XX        RR  RR  RRRRRRRR                                      \r\n];\r\n// Blue Maze Entry                                                                                                   \r\nvar roomGfxBlueMazeEntry = [\r\n    0xF0, 0xF3, 0xCC,\r\n    0x00, 0x33, 0x0C,\r\n    0xF0, 0x33, 0xFC,\r\n    0x00, 0x33, 0x00,\r\n    0xF0, 0xF3, 0xFF,\r\n    0x00, 0x00, 0x00,\r\n    0xF0, 0xFF, 0x0F // XXXXXXXXXXXXXXXX        RRRRRRRRRRRRRRRR                                      \r\n];\r\n// Maze Middle                                                                                                       \r\nvar roomGfxMazeMiddle = [\r\n    0xF0, 0xFF, 0xCC,\r\n    0x00, 0x00, 0xCC,\r\n    0xF0, 0x03, 0xCF,\r\n    0x00, 0x03, 0x00,\r\n    0xF0, 0xF3, 0xFC,\r\n    0x00, 0x33, 0x0C,\r\n    0xF0, 0x33, 0xCC // XXXX  XX  XX  XX  XXRR  RR  RR  RR  RRRR\r\n];\r\n// Maze Side \r\nvar roomGfxMazeSide = [\r\n    0xF0, 0x33, 0xCC,\r\n    0x00, 0x30, 0xCC,\r\n    0x00, 0x3F, 0xCF,\r\n    0x00, 0x00, 0xC0,\r\n    0x00, 0x3F, 0xC3,\r\n    0x00, 0x30, 0xC0,\r\n    0xF0, 0xFF, 0xFF // XXXXXXXXXXXXXXXXXXXXRRRRRRRRRRRRRRRRRRRR                                      \r\n];\r\n// Maze Entry                                                                                                        \r\nvar roomGfxMazeEntry = [\r\n    0xF0, 0xFF, 0x0F,\r\n    0x00, 0x30, 0x00,\r\n    0xF0, 0x30, 0xFF,\r\n    0x00, 0x30, 0xC0,\r\n    0xF0, 0xF3, 0xC0,\r\n    0x00, 0x03, 0xC0,\r\n    0xF0, 0xFF, 0xCC // XXXXXXXXXXXX  XX  XXRR  RR  RRRRRRRRRRRR                                      \r\n];\r\n// Castle\r\nvar roomGfxCastle = [\r\n    0xF0, 0xFE, 0x15,\r\n    0x30, 0x03, 0x1F,\r\n    0x30, 0x03, 0xFF,\r\n    0x30, 0x00, 0xFF,\r\n    0x30, 0x00, 0x3F,\r\n    0x30, 0x00, 0x00,\r\n    0xF0, 0xFF, 0x0F // XXXXXXXXXXXXXX            RRRRRRRRRRRRRR                                      \r\n];\r\n// Red Maze #1                                                                                                       \r\nvar roomGfxRedMaze1 = [\r\n    0xF0, 0xFF, 0xFF,\r\n    0x00, 0x00, 0x00,\r\n    0xF0, 0xFF, 0x0F,\r\n    0x00, 0x00, 0x0C,\r\n    0xF0, 0xFF, 0x0C,\r\n    0xF0, 0x03, 0xCC,\r\n    0xF0, 0x33, 0xCF // XXXX  XX  XXXXXX  XXRR  RRRRRR  RR  RRRR\r\n];\r\n// Bottom of Red Maze                                                                                                \r\nvar roomGfxRedMazeBottom = [\r\n    0xF0, 0x33, 0xCF,\r\n    0xF0, 0x30, 0x00,\r\n    0xF0, 0x33, 0xFF,\r\n    0x00, 0x33, 0x00,\r\n    0xF0, 0xFF, 0x00,\r\n    0x00, 0x00, 0x00,\r\n    0xF0, 0xFF, 0x0F // XXXXXXXXXXXXXXXX        RRRRRRRRRRRRRRRR                                      \r\n];\r\n// Top of Red Maze                                                                                                   \r\nvar roomGfxRedMazeTop = [\r\n    0xF0, 0xFF, 0xFF,\r\n    0x00, 0x00, 0xC0,\r\n    0xF0, 0xFF, 0xCF,\r\n    0x00, 0x00, 0xCC,\r\n    0xF0, 0x33, 0xFF,\r\n    0xF0, 0x33, 0x00,\r\n    0xF0, 0x3F, 0x0C // XXXX  XXXXXX  XX        RR  RRRRRR  RRRR\r\n];\r\n// White Castle Entry                                                                                                \r\nvar roomGfxWhiteCastleEntry = [\r\n    0xF0, 0x3F, 0x0C,\r\n    0xF0, 0x00, 0x0C,\r\n    0xF0, 0xFF, 0x0F,\r\n    0x00, 0x30, 0x00,\r\n    0xF0, 0x30, 0x00,\r\n    0x00, 0x30, 0x00,\r\n    0xF0, 0xFF, 0x0F // XXXXXXXXXXXXXXXX        RRRRRRRRRRRRRRRR                                      \r\n];\r\n// Top Entry Room  \r\nvar roomGfxTopEntryRoom = [\r\n    0xF0, 0xFF, 0x0F,\r\n    0x30, 0x00, 0x00,\r\n    0x30, 0x00, 0x00,\r\n    0x30, 0x00, 0x00,\r\n    0x30, 0x00, 0x00,\r\n    0x30, 0x00, 0x00,\r\n    0xF0, 0xFF, 0xFF // XXXXXXXXXXXXXXXXXXXXRRRRRRRRRRRRRRRRRRRR                                      \r\n];\r\n// Black Maze #1                                                                                                     \r\nvar roomGfxBlackMaze1 = [\r\n    0xF0, 0xF0, 0xFF,\r\n    0x00, 0x00, 0x03,\r\n    0xF0, 0xFF, 0x03,\r\n    0x00, 0x00, 0x00,\r\n    0x30, 0x3F, 0xFF,\r\n    0x00, 0x30, 0x00,\r\n    0xF0, 0xF0, 0xFF // XXXXXXXX    XXXXXXXXRRRRRRRR    RRRRRRRR\r\n];\r\n// Black Maze #3                                                                                                     \r\nvar roomGfxBlackMaze3 = [\r\n    0xF0, 0xF0, 0xFF,\r\n    0x30, 0x00, 0x00,\r\n    0x30, 0x3F, 0xFF,\r\n    0x00, 0x30, 0x00,\r\n    0xF0, 0xF0, 0xFF,\r\n    0x30, 0x00, 0x03,\r\n    0xF0, 0xF0, 0xFF // XXXXXXXX    XXXXXXXXMMMMMMMM    MMMMMMMM                                      \r\n];\r\n// Black Maze #2                                                                                                     \r\nvar roomGfxBlackMaze2 = [\r\n    0xF0, 0xFF, 0xFF,\r\n    0x00, 0x00, 0xC0,\r\n    0xF0, 0xFF, 0xCF,\r\n    0x00, 0x00, 0x0C,\r\n    0xF0, 0x0F, 0xFF,\r\n    0x00, 0x0F, 0xC0,\r\n    0x30, 0xCF, 0xCC // XX  XX  XXXX  XX  XXMM  MM  MMMM  MM  MM\r\n];\r\n// Black Maze Entry                                                                                                  \r\nvar roomGfxBlackMazeEntry = [\r\n    0x30, 0xCF, 0xCC,\r\n    0x00, 0xC0, 0xCC,\r\n    0xF0, 0xFF, 0x0F,\r\n    0x00, 0x00, 0x00,\r\n    0xF0, 0xFF, 0x0F,\r\n    0x00, 0x00, 0x00,\r\n    0xF0, 0xFF, 0x0F // XXXXXXXXXXXXXXXX        RRRRRRRRRRRRRRRR                                      \r\n];\r\n// Object definitions - 1st byte is the height\r\nvar objectGfxNum = [\r\n    // Object #5 State #1 Graphic :'1'\r\n    7,\r\n    0x04,\r\n    0x0C,\r\n    0x04,\r\n    0x04,\r\n    0x04,\r\n    0x04,\r\n    0x0E,\r\n    // Object #5 State #2 Grphic : '2'                                                                                   \r\n    7,\r\n    0x0E,\r\n    0x11,\r\n    0x01,\r\n    0x02,\r\n    0x04,\r\n    0x08,\r\n    0x1F,\r\n    // Object #5 State #3 Graphic :'3'                                                                                   \r\n    7,\r\n    0x0E,\r\n    0x11,\r\n    0x01,\r\n    0x06,\r\n    0x01,\r\n    0x11,\r\n    0x0E //  XXX                                                                      \r\n];\r\n// Number states\r\nvar numberStates = [\r\n    0, 1, 2\r\n];\r\n// Object #0B : State FF : Graphic\r\nvar objectGfxKey = [\r\n    3,\r\n    0x07,\r\n    0xFD,\r\n    0xA7 // X X  XXX\r\n];\r\n// Object #1 : Graphic\r\nvar objectGfxSurround = [\r\n    32,\r\n    0xFF,\r\n    0xFF,\r\n    0xFF,\r\n    0xFF,\r\n    0xFF,\r\n    0xFF,\r\n    0xFF,\r\n    0xFF,\r\n    0xFF,\r\n    0xFF,\r\n    0xFF,\r\n    0xFF,\r\n    0xFF,\r\n    0xFF,\r\n    0xFF,\r\n    0xFF,\r\n    0xFF,\r\n    0xFF,\r\n    0xFF,\r\n    0xFF,\r\n    0xFF,\r\n    0xFF,\r\n    0xFF,\r\n    0xFF,\r\n    0xFF,\r\n    0xFF,\r\n    0xFF,\r\n    0xFF,\r\n    0xFF,\r\n    0xFF,\r\n    0xFF,\r\n    0xFF // XXXXXXXX                                                                  \r\n];\r\nvar objectSurround = {\r\n    gfxData: objectGfxSurround,\r\n    states: [0],\r\n    state: 0,\r\n    color: COLOR_ORANGE,\r\n    room: -1,\r\n    x: 0,\r\n    y: 0,\r\n    movementX: 0,\r\n    movementY: 0,\r\n    size: 0x07,\r\n    linkedObject: OBJECT_NONE,\r\n    linkedObjectX: 0,\r\n    linkedObjectY: 0,\r\n    displayed: true\r\n};\r\n// Object #0A : State FF : Graphic                                                                                   \r\nvar objectGfxBridge = [\r\n    24,\r\n    0xC3,\r\n    0xC3,\r\n    0xC3,\r\n    0xC3,\r\n    0x42,\r\n    0x42,\r\n    0x42,\r\n    0x42,\r\n    0x42,\r\n    0x42,\r\n    0x42,\r\n    0x42,\r\n    0x42,\r\n    0x42,\r\n    0x42,\r\n    0x42,\r\n    0x42,\r\n    0x42,\r\n    0x42,\r\n    0x42,\r\n    0xC3,\r\n    0xC3,\r\n    0xC3,\r\n    0xC3 // XX    XX                                                                  \r\n];\r\nvar objectGfxBat = [\r\n    // Object #0E : State 03 : Graphic                                                                                   \r\n    7,\r\n    0x81,\r\n    0x81,\r\n    0xC3,\r\n    0xC3,\r\n    0xFF,\r\n    0x5A,\r\n    0x66,\r\n    // Object #0E : State FF : Graphic                                                                                   \r\n    11,\r\n    0x01,\r\n    0x80,\r\n    0x01,\r\n    0x80,\r\n    0x3C,\r\n    0x5A,\r\n    0x66,\r\n    0xC3,\r\n    0x81,\r\n    0x81,\r\n    0x81 // X      X                                                                  \r\n];\r\n// Bat states\r\nvar batStates = [\r\n    0, 1\r\n];\r\nvar objectGfxDrag = [\r\n    // Object #6 : State #00 : Graphic                                                                                   \r\n    20,\r\n    0x06,\r\n    0x0F,\r\n    0xF3,\r\n    0xFE,\r\n    0x0E,\r\n    0x04,\r\n    0x04,\r\n    0x1E,\r\n    0x3F,\r\n    0x7F,\r\n    0xE3,\r\n    0xC3,\r\n    0xC3,\r\n    0xC7,\r\n    0xFF,\r\n    0x3C,\r\n    0x08,\r\n    0x8F,\r\n    0xE1,\r\n    0x3F,\r\n    // Object 6 : State 01 : Graphic                                                                                     \r\n    22,\r\n    0x80,\r\n    0x40,\r\n    0x26,\r\n    0x1F,\r\n    0x0B,\r\n    0x0E,\r\n    0x1E,\r\n    0x24,\r\n    0x44,\r\n    0x8E,\r\n    0x1E,\r\n    0x3F,\r\n    0x7F,\r\n    0x7F,\r\n    0x7F,\r\n    0x7F,\r\n    0x3E,\r\n    0x1C,\r\n    0x08,\r\n    0xF8,\r\n    0x80,\r\n    0xE0,\r\n    // Object 6 : State 02 : Graphic                                                                                     \r\n    17,\r\n    0x0C,\r\n    0x0C,\r\n    0x0C,\r\n    0x0E,\r\n    0x1B,\r\n    0x7F,\r\n    0xCE,\r\n    0x80,\r\n    0xFC,\r\n    0xFE,\r\n    0xFE,\r\n    0x7E,\r\n    0x78,\r\n    0x20,\r\n    0x6E,\r\n    0x42,\r\n    0x7E //  XXXXXX                                                                   \r\n];\r\n// Dragon states\r\nvar dragonStates = [\r\n    0, 2, 0, 1\r\n];\r\n// Dragon Difficulty\r\nvar dragonDiff = [\r\n    0xD0, 0xE8,\r\n    0xF0, 0xF6,\r\n    0xF0, 0xF6 // Level 3 : Am, Pro\r\n];\r\n// Object #9 : State FF : Graphics                                                                                   \r\nvar objectGfxSword = [\r\n    5,\r\n    0x20,\r\n    0x40,\r\n    0xFF,\r\n    0x40,\r\n    0x20 //   X                                                                       \r\n];\r\n// Object #0F : State FF : Graphic                                                                                   \r\nvar objectGfxDot = [\r\n    1,\r\n    0x80 // X                                                                         \r\n];\r\n// Object #4 : State FF : Graphic                                                                                    \r\nvar objectGfxAuthor = [\r\n    95,\r\n    0xF0,\r\n    0x80,\r\n    0x80,\r\n    0x80,\r\n    0xF4,\r\n    0x04,\r\n    0x87,\r\n    0xE5,\r\n    0x87,\r\n    0x80,\r\n    0x05,\r\n    0xE5,\r\n    0xA7,\r\n    0xE1,\r\n    0x87,\r\n    0xE0,\r\n    0x01,\r\n    0xE0,\r\n    0xA0,\r\n    0xF0,\r\n    0x01,\r\n    0x40,\r\n    0xE0,\r\n    0x40,\r\n    0x40,\r\n    0x40,\r\n    0x01,\r\n    0xE0,\r\n    0xA0,\r\n    0xE0,\r\n    0x80,\r\n    0xE0,\r\n    0x01,\r\n    0x20,\r\n    0x20,\r\n    0xE0,\r\n    0xA0,\r\n    0xE0,\r\n    0x01,\r\n    0x01,\r\n    0x01,\r\n    0x88,\r\n    0xA8,\r\n    0xA8,\r\n    0xA8,\r\n    0xF8,\r\n    0x01,\r\n    0xE0,\r\n    0xA0,\r\n    0xF0,\r\n    0x01,\r\n    0x80,\r\n    0xE0,\r\n    0x8F,\r\n    0x89,\r\n    0x0F,\r\n    0x8A,\r\n    0xE9,\r\n    0x80,\r\n    0x8E,\r\n    0x0A,\r\n    0xEE,\r\n    0xA0,\r\n    0xE8,\r\n    0x88,\r\n    0xEE,\r\n    0x0A,\r\n    0x8E,\r\n    0xE0,\r\n    0xA4,\r\n    0xA4,\r\n    0x04,\r\n    0x80,\r\n    0x08,\r\n    0x0E,\r\n    0x0A,\r\n    0x0A,\r\n    0x80,\r\n    0x0E,\r\n    0x0A,\r\n    0x0E,\r\n    0x08,\r\n    0x0E,\r\n    0x80,\r\n    0x04,\r\n    0x0E,\r\n    0x04,\r\n    0x04,\r\n    0x04,\r\n    0x80,\r\n    0x04,\r\n    0x0E,\r\n    0x04,\r\n    0x04,\r\n    0x04 //      X                                                                    \r\n];\r\n// Object #10 : State FF : Graphic                                                                                   \r\nvar objectGfxChallise = [\r\n    9,\r\n    0x81,\r\n    0x81,\r\n    0xC3,\r\n    0x7E,\r\n    0x7E,\r\n    0x3C,\r\n    0x18,\r\n    0x18,\r\n    0x7E //  XXXXXX                                                                   \r\n];\r\n// Object #11 : State FF : Graphic                                                                                   \r\nvar objectGfxMagnet = [\r\n    8,\r\n    0x3C,\r\n    0x7E,\r\n    0xE7,\r\n    0xC3,\r\n    0xC3,\r\n    0xC3,\r\n    0xC3,\r\n    0xC3 // XX    XX                                                                  \r\n];\r\n// Object #1 States 940FF (Graphic)                                                                                  \r\nvar objectGfxPort = [\r\n    // state 1\r\n    4,\r\n    0xFE,\r\n    0xAA,\r\n    0xFE,\r\n    0xAA,\r\n    // state 2\r\n    6,\r\n    0xFE,\r\n    0xAA,\r\n    0xFE,\r\n    0xAA,\r\n    0xFE,\r\n    0xAA,\r\n    // state 3\r\n    8,\r\n    0xFE,\r\n    0xAA,\r\n    0xFE,\r\n    0xAA,\r\n    0xFE,\r\n    0xAA,\r\n    0xFE,\r\n    0xAA,\r\n    // state 4\r\n    10,\r\n    0xFE,\r\n    0xAA,\r\n    0xFE,\r\n    0xAA,\r\n    0xFE,\r\n    0xAA,\r\n    0xFE,\r\n    0xAA,\r\n    0xFE,\r\n    0xAA,\r\n    // state 5\r\n    12,\r\n    0xFE,\r\n    0xAA,\r\n    0xFE,\r\n    0xAA,\r\n    0xFE,\r\n    0xAA,\r\n    0xFE,\r\n    0xAA,\r\n    0xFE,\r\n    0xAA,\r\n    0xFE,\r\n    0xAA,\r\n    // state 6\r\n    14,\r\n    0xFE,\r\n    0xAA,\r\n    0xFE,\r\n    0xAA,\r\n    0xFE,\r\n    0xAA,\r\n    0xFE,\r\n    0xAA,\r\n    0xFE,\r\n    0xAA,\r\n    0xFE,\r\n    0xAA,\r\n    0xFE,\r\n    0xAA,\r\n    // state 7\r\n    16,\r\n    0xFE,\r\n    0xAA,\r\n    0xFE,\r\n    0xAA,\r\n    0xFE,\r\n    0xAA,\r\n    0xFE,\r\n    0xAA,\r\n    0xFE,\r\n    0xAA,\r\n    0xFE,\r\n    0xAA,\r\n    0xFE,\r\n    0xAA,\r\n    0xFE,\r\n    0xAA // X X X X                                                                   \r\n];\r\n// Portcullis states\r\nvar portStates = [\r\n    0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 1\r\n];\r\n// The ball\r\nvar objectBall = {\r\n    room: 0,\r\n    x: 0,\r\n    y: 0,\r\n    previousX: 0,\r\n    previousY: 0,\r\n    linkedObject: OBJECT_NONE,\r\n    linkedObjectX: 0,\r\n    linkedObjectY: 0,\r\n    hitX: false,\r\n    hitY: false,\r\n    hitObject: OBJECT_NONE\r\n};\r\n// Define all the game objects\r\nvar objectDefs = [\r\n    { gfxData: objectGfxPort, states: portStates, state: 0, color: COLOR_BLACK, room: -1, x: 0, y: 0, movementX: 0, movementY: 0, size: 0, linkedObject: 0, linkedObjectX: 0, linkedObjectY: 0, displayed: false },\r\n    { gfxData: objectGfxPort, states: portStates, state: 0, color: COLOR_BLACK, room: -1, x: 0, y: 0, movementX: 0, movementY: 0, size: 0, linkedObject: 0, linkedObjectX: 0, linkedObjectY: 0, displayed: false },\r\n    { gfxData: objectGfxPort, states: portStates, state: 0, color: COLOR_BLACK, room: -1, x: 0, y: 0, movementX: 0, movementY: 0, size: 0, linkedObject: 0, linkedObjectX: 0, linkedObjectY: 0, displayed: false },\r\n    { gfxData: objectGfxAuthor, states: [0], state: 0, color: COLOR_FLASH, room: 0x1E, x: 0x50, y: 0x69, movementX: 0, movementY: 0, size: 0, linkedObject: 0, linkedObjectX: 0, linkedObjectY: 0, displayed: false },\r\n    { gfxData: objectGfxNum, states: numberStates, state: 0, color: COLOR_LIMEGREEN, room: 0x00, x: 0x50, y: 0x40, movementX: 0, movementY: 0, size: 0, linkedObject: 0, linkedObjectX: 0, linkedObjectY: 0, displayed: false },\r\n    { gfxData: objectGfxDrag, states: dragonStates, state: 0, color: COLOR_RED, room: -1, x: 0, y: 0, movementX: 0, movementY: 0, size: 0, linkedObject: 0, linkedObjectX: 0, linkedObjectY: 0, displayed: false },\r\n    { gfxData: objectGfxDrag, states: dragonStates, state: 0, color: COLOR_YELLOW, room: -1, x: 0, y: 0, movementX: 0, movementY: 0, size: 0, linkedObject: 0, linkedObjectX: 0, linkedObjectY: 0, displayed: false },\r\n    { gfxData: objectGfxDrag, states: dragonStates, state: 0, color: COLOR_LIMEGREEN, room: -1, x: 0, y: 0, movementX: 0, movementY: 0, size: 0, linkedObject: 0, linkedObjectX: 0, linkedObjectY: 0, displayed: false },\r\n    { gfxData: objectGfxSword, states: [0], state: 0, color: COLOR_YELLOW, room: -1, x: 0, y: 0, movementX: 0, movementY: 0, size: 0, linkedObject: 0, linkedObjectX: 0, linkedObjectY: 0, displayed: false },\r\n    { gfxData: objectGfxBridge, states: [0], state: 0, color: COLOR_PURPLE, room: -1, x: 0, y: 0, movementX: 0, movementY: 0, size: 0x07, linkedObject: 0, linkedObjectX: 0, linkedObjectY: 0, displayed: false },\r\n    { gfxData: objectGfxKey, states: [0], state: 0, color: COLOR_YELLOW, room: -1, x: 0, y: 0, movementX: 0, movementY: 0, size: 0, linkedObject: 0, linkedObjectX: 0, linkedObjectY: 0, displayed: false },\r\n    { gfxData: objectGfxKey, states: [0], state: 0, color: COLOR_WHITE, room: -1, x: 0, y: 0, movementX: 0, movementY: 0, size: 0, linkedObject: 0, linkedObjectX: 0, linkedObjectY: 0, displayed: false },\r\n    { gfxData: objectGfxKey, states: [0], state: 0, color: COLOR_BLACK, room: -1, x: 0, y: 0, movementX: 0, movementY: 0, size: 0, linkedObject: 0, linkedObjectX: 0, linkedObjectY: 0, displayed: false },\r\n    { gfxData: objectGfxBat, states: batStates, state: 0, color: COLOR_BLACK, room: -1, x: 0, y: 0, movementX: 0, movementY: 0, size: 0, linkedObject: 0, linkedObjectX: 0, linkedObjectY: 0, displayed: false },\r\n    { gfxData: objectGfxDot, states: [0], state: 0, color: COLOR_LTGRAY, room: -1, x: 0, y: 0, movementX: 0, movementY: 0, size: 0, linkedObject: 0, linkedObjectX: 0, linkedObjectY: 0, displayed: false },\r\n    { gfxData: objectGfxChallise, states: [0], state: 0, color: COLOR_FLASH, room: -1, x: 0, y: 0, movementX: 0, movementY: 0, size: 0, linkedObject: 0, linkedObjectX: 0, linkedObjectY: 0, displayed: false },\r\n    { gfxData: objectGfxMagnet, states: [0], state: 0, color: COLOR_BLACK, room: -1, x: 0, y: 0, movementX: 0, movementY: 0, size: 0, linkedObject: 0, linkedObjectX: 0, linkedObjectY: 0, displayed: false },\r\n    { gfxData: null, states: [0], state: 0, color: 0, room: -1, x: 0, y: 0, movementX: 0, movementY: 0, size: 0, linkedObject: 0, linkedObjectX: 0, linkedObjectY: 0, displayed: false } // #12 Null\r\n];\r\n// Object locations (room and coordinate) for game 01\r\n//        - object, room, x, y, state, movement(x/y)\r\nvar game1Objects = [\r\n    OBJECT_PORT1, 0x11, 0x4d, 0x31, 0x0C, 0x00, 0x00,\r\n    OBJECT_PORT2, 0x0F, 0x4d, 0x31, 0x0C, 0x00, 0x00,\r\n    OBJECT_PORT3, 0x10, 0x4d, 0x31, 0x0C, 0x00, 0x00,\r\n    OBJECT_REDDRAGON, 0x0E, 0x50, 0x20, 0x00, 0x00, 0x00,\r\n    OBJECT_YELLOWDRAGON, 0x01, 0x50, 0x20, 0x00, 0x00, 0x00,\r\n    OBJECT_GREENDRAGON, 0x1D, 0x50, 0x20, 0x00, 0x00, 0x00,\r\n    OBJECT_SWORD, 0x12, 0x20, 0x20, 0x00, 0x00, 0x00,\r\n    OBJECT_BRIDGE, 0x04, 0x2A, 0x37, 0x00, 0x00, 0x00,\r\n    OBJECT_YELLOWKEY, 0x11, 0x20, 0x40, 0x00, 0x00, 0x00,\r\n    OBJECT_WHITEKEY, 0x0E, 0x20, 0x40, 0x00, 0x00, 0x00,\r\n    OBJECT_BLACKKEY, 0x1D, 0x20, 0x40, 0x00, 0x00, 0x00,\r\n    OBJECT_BAT, 0x1A, 0x20, 0x20, 0x00, 0x00, 0x00,\r\n    OBJECT_DOT, 0x15, 0x51, 0x12, 0x00, 0x00, 0x00,\r\n    OBJECT_CHALISE, 0x1C, 0x30, 0x20, 0x00, 0x00, 0x00,\r\n    OBJECT_MAGNET, 0x1B, 0x80, 0x20, 0x00, 0x00, 0x00,\r\n    0xff, 0, 0, 0, 0, 0, 0\r\n];\r\n// Object locations (room and coordinate) for Games 02 and 03\r\n//        - object, room, x, y, state, movement(x/y)\r\nvar game2Objects = [\r\n    OBJECT_PORT1, 0x11, 0x4d, 0x31, 0x0C, 0x00, 0x00,\r\n    OBJECT_PORT2, 0x0F, 0x4d, 0x31, 0x0C, 0x00, 0x00,\r\n    OBJECT_PORT3, 0x10, 0x4d, 0x31, 0x0C, 0x00, 0x00,\r\n    OBJECT_REDDRAGON, 0x14, 0x50, 0x20, 0x00, 3, 3,\r\n    OBJECT_YELLOWDRAGON, 0x19, 0x50, 0x20, 0x00, 3, 3,\r\n    OBJECT_GREENDRAGON, 0x04, 0x50, 0x20, 0x00, 3, 3,\r\n    OBJECT_SWORD, 0x11, 0x20, 0x20, 0x00, 0x00, 0x00,\r\n    OBJECT_BRIDGE, 0x0B, 0x40, 0x40, 0x00, 0x00, 0x00,\r\n    OBJECT_YELLOWKEY, 0x09, 0x20, 0x40, 0x00, 0x00, 0x00,\r\n    OBJECT_WHITEKEY, 0x06, 0x20, 0x40, 0x00, 0x00, 0x00,\r\n    OBJECT_BLACKKEY, 0x19, 0x20, 0x40, 0x00, 0x00, 0x00,\r\n    OBJECT_BAT, 0x02, 0x20, 0x20, 0x00, 0, -3,\r\n    OBJECT_DOT, 0x15, 0x45, 0x12, 0x00, 0x00, 0x00,\r\n    OBJECT_CHALISE, 0x14, 0x30, 0x20, 0x00, 0x00, 0x00,\r\n    OBJECT_MAGNET, 0x0E, 0x80, 0x20, 0x00, 0x00, 0x00,\r\n    0xff, 0, 0, 0, 0, 0, 0\r\n];\r\n// Room bounds data for game level 3\r\n// Ex. the chalise can only exist in rooms 13-1A\r\nvar roomBoundsData = [\r\n    OBJECT_CHALISE, 0x13, 0x1A,\r\n    OBJECT_REDDRAGON, 0x01, 0x1D,\r\n    OBJECT_YELLOWDRAGON, 0x01, 0x1D,\r\n    OBJECT_GREENDRAGON, 0x01, 0x1D,\r\n    OBJECT_SWORD, 0x01, 0x1D,\r\n    OBJECT_BRIDGE, 0x01, 0x1D,\r\n    OBJECT_YELLOWKEY, 0x01, 0x1D,\r\n    OBJECT_WHITEKEY, 0x01, 0x16,\r\n    OBJECT_BLACKKEY, 0x01, 0x12,\r\n    OBJECT_BAT, 0x01, 0x1D,\r\n    OBJECT_MAGNET, 0x01, 0x1D,\r\n    OBJECT_NONE, 0, 0\r\n];\r\n// Indexed array of all rooms and their properties\r\nvar roomDefs = [\r\n    { graphicsData: roomGfxNumberRoom, flags: ROOMFLAG_NONE, color: COLOR_PURPLE, roomUp: 0x00, roomRight: 0x00, roomDown: 0x00, roomLeft: 0x00 },\r\n    { graphicsData: roomGfxBelowYellowCastle, flags: ROOMFLAG_LEFTTHINWALL, color: COLOR_OLIVEGREEN, roomUp: 0x08, roomRight: 0x02, roomDown: 0x80, roomLeft: 0x03 },\r\n    { graphicsData: roomGfxBelowYellowCastle, flags: ROOMFLAG_NONE, color: COLOR_LIMEGREEN, roomUp: 0x11, roomRight: 0x03, roomDown: 0x83, roomLeft: 0x01 },\r\n    { graphicsData: roomGfxLeftOfName, flags: ROOMFLAG_RIGHTTHINWALL, color: COLOR_TAN, roomUp: 0x06, roomRight: 0x01, roomDown: 0x86, roomLeft: 0x02 },\r\n    { graphicsData: roomGfxBlueMazeTop, flags: ROOMFLAG_NONE, color: COLOR_BLUE, roomUp: 0x10, roomRight: 0x05, roomDown: 0x07, roomLeft: 0x06 },\r\n    { graphicsData: roomGfxBlueMaze1, flags: ROOMFLAG_NONE, color: COLOR_BLUE, roomUp: 0x1D, roomRight: 0x06, roomDown: 0x08, roomLeft: 0x04 },\r\n    { graphicsData: roomGfxBlueMazeBottom, flags: ROOMFLAG_NONE, color: COLOR_BLUE, roomUp: 0x07, roomRight: 0x04, roomDown: 0x03, roomLeft: 0x05 },\r\n    { graphicsData: roomGfxBlueMazeCenter, flags: ROOMFLAG_NONE, color: COLOR_BLUE, roomUp: 0x04, roomRight: 0x08, roomDown: 0x06, roomLeft: 0x08 },\r\n    { graphicsData: roomGfxBlueMazeEntry, flags: ROOMFLAG_NONE, color: COLOR_BLUE, roomUp: 0x05, roomRight: 0x07, roomDown: 0x01, roomLeft: 0x07 },\r\n    { graphicsData: roomGfxMazeMiddle, flags: ROOMFLAG_NONE, color: COLOR_LTGRAY, roomUp: 0x0A, roomRight: 0x0A, roomDown: 0x0B, roomLeft: 0x0A },\r\n    { graphicsData: roomGfxMazeEntry, flags: ROOMFLAG_NONE, color: COLOR_LTGRAY, roomUp: 0x03, roomRight: 0x09, roomDown: 0x09, roomLeft: 0x09 },\r\n    { graphicsData: roomGfxMazeSide, flags: ROOMFLAG_NONE, color: COLOR_LTGRAY, roomUp: 0x09, roomRight: 0x0C, roomDown: 0x1C, roomLeft: 0x0D },\r\n    { graphicsData: roomGfxSideCorridor, flags: ROOMFLAG_RIGHTTHINWALL, color: COLOR_LTCYAN, roomUp: 0x1C, roomRight: 0x0D, roomDown: 0x1D, roomLeft: 0x0B },\r\n    { graphicsData: roomGfxSideCorridor, flags: ROOMFLAG_LEFTTHINWALL, color: COLOR_DKGREEN, roomUp: 0x0F, roomRight: 0x0B, roomDown: 0x0E, roomLeft: 0x0C },\r\n    { graphicsData: roomGfxTopEntryRoom, flags: ROOMFLAG_NONE, color: COLOR_CYAN, roomUp: 0x0D, roomRight: 0x10, roomDown: 0x0F, roomLeft: 0x10 },\r\n    { graphicsData: roomGfxCastle, flags: ROOMFLAG_NONE, color: COLOR_WHITE, roomUp: 0x0E, roomRight: 0x0F, roomDown: 0x0D, roomLeft: 0x0F },\r\n    { graphicsData: roomGfxCastle, flags: ROOMFLAG_NONE, color: COLOR_BLACK, roomUp: 0x01, roomRight: 0x1C, roomDown: 0x04, roomLeft: 0x1C },\r\n    { graphicsData: roomGfxCastle, flags: ROOMFLAG_NONE, color: COLOR_YELLOW, roomUp: 0x06, roomRight: 0x03, roomDown: 0x02, roomLeft: 0x01 },\r\n    { graphicsData: roomGfxNumberRoom, flags: ROOMFLAG_NONE, color: COLOR_YELLOW, roomUp: 0x12, roomRight: 0x12, roomDown: 0x12, roomLeft: 0x12 },\r\n    { graphicsData: roomGfxBlackMaze1, flags: ROOMFLAG_NONE, color: COLOR_LTGRAY, roomUp: 0x15, roomRight: 0x14, roomDown: 0x15, roomLeft: 0x16 },\r\n    { graphicsData: roomGfxBlackMaze2, flags: ROOMFLAG_MIRROR, color: COLOR_LTGRAY, roomUp: 0x16, roomRight: 0x15, roomDown: 0x16, roomLeft: 0x13 },\r\n    { graphicsData: roomGfxBlackMaze3, flags: ROOMFLAG_MIRROR, color: COLOR_LTGRAY, roomUp: 0x13, roomRight: 0x16, roomDown: 0x13, roomLeft: 0x14 },\r\n    { graphicsData: roomGfxBlackMazeEntry, flags: ROOMFLAG_NONE, color: COLOR_LTGRAY, roomUp: 0x14, roomRight: 0x13, roomDown: 0x1B, roomLeft: 0x15 },\r\n    { graphicsData: roomGfxRedMaze1, flags: ROOMFLAG_NONE, color: COLOR_RED, roomUp: 0x19, roomRight: 0x18, roomDown: 0x19, roomLeft: 0x18 },\r\n    { graphicsData: roomGfxRedMazeTop, flags: ROOMFLAG_NONE, color: COLOR_RED, roomUp: 0x1A, roomRight: 0x17, roomDown: 0x1A, roomLeft: 0x17 },\r\n    { graphicsData: roomGfxRedMazeBottom, flags: ROOMFLAG_NONE, color: COLOR_RED, roomUp: 0x17, roomRight: 0x1A, roomDown: 0x17, roomLeft: 0x1A },\r\n    { graphicsData: roomGfxWhiteCastleEntry, flags: ROOMFLAG_NONE, color: COLOR_RED, roomUp: 0x18, roomRight: 0x19, roomDown: 0x18, roomLeft: 0x19 },\r\n    { graphicsData: roomGfxTwoExitRoom, flags: ROOMFLAG_NONE, color: COLOR_RED, roomUp: 0x89, roomRight: 0x89, roomDown: 0x89, roomLeft: 0x89 },\r\n    { graphicsData: roomGfxNumberRoom, flags: ROOMFLAG_NONE, color: COLOR_PURPLE, roomUp: 0x1D, roomRight: 0x07, roomDown: 0x8C, roomLeft: 0x08 },\r\n    { graphicsData: roomGfxTopEntryRoom, flags: ROOMFLAG_NONE, color: COLOR_RED, roomUp: 0x8F, roomRight: 0x01, roomDown: 0x10, roomLeft: 0x03 },\r\n    { graphicsData: roomGfxBelowYellowCastle, flags: ROOMFLAG_NONE, color: COLOR_PURPLE, roomUp: 0x06, roomRight: 0x01, roomDown: 0x06, roomLeft: 0x03 } // 1E - Name Room\r\n];\r\n// Room differences for different levels (level 1,2,3)  \r\nvar roomLevelDiffs = [\r\n    0x10, 0x0f, 0x0f,\r\n    0x05, 0x11, 0x11,\r\n    0x1d, 0x0a, 0x0a,\r\n    0x1c, 0x16, 0x16,\r\n    0x1b, 0x0c, 0x0c,\r\n    0x03, 0x0c, 0x0c // up from room 1d (top entry room)    \r\n];\r\n// Castle Entry Rooms (Yellow, White, Black)\r\nvar entryRoomOffsets = [\r\n    0x12, 0x1A, 0x1B\r\n];\r\n// Castle Rooms (Yellow, White, Black)                                                                               \r\nvar castleRoomOffsets = [\r\n    0x11, 0x0F, 0x10\r\n];\r\n// Magnet Object Matrix                                                                             \r\nvar magnetMatrix = [\r\n    OBJECT_YELLOWKEY,\r\n    OBJECT_WHITEKEY,\r\n    OBJECT_BLACKKEY,\r\n    OBJECT_SWORD,\r\n    OBJECT_BRIDGE,\r\n    OBJECT_CHALISE,\r\n    0x00\r\n];\r\n// Green Dragon's Object Matrix                                                                                      \r\nvar greenDragonMatrix = [\r\n    OBJECT_SWORD, OBJECT_GREENDRAGON,\r\n    OBJECT_GREENDRAGON, OBJECT_BALL,\r\n    OBJECT_GREENDRAGON, OBJECT_CHALISE,\r\n    OBJECT_GREENDRAGON, OBJECT_BRIDGE,\r\n    OBJECT_GREENDRAGON, OBJECT_MAGNET,\r\n    OBJECT_GREENDRAGON, OBJECT_BLACKKEY,\r\n    0x00, 0x00\r\n];\r\n// Yellow Dragon's Object Matrix                                                                                      \r\nvar yellowDragonMatrix = [\r\n    OBJECT_SWORD, OBJECT_YELLOWDRAGON,\r\n    OBJECT_YELLOWKEY, OBJECT_YELLOWDRAGON,\r\n    OBJECT_YELLOWDRAGON, OBJECT_BALL,\r\n    OBJECT_YELLOWDRAGON, OBJECT_CHALISE,\r\n    0x00, 0x00\r\n];\r\n// Red Dragon's Object Matrix                                                                                      \r\nvar redDragonMatrix = [\r\n    OBJECT_SWORD, OBJECT_REDDRAGON,\r\n    OBJECT_REDDRAGON, OBJECT_BALL,\r\n    OBJECT_REDDRAGON, OBJECT_CHALISE,\r\n    OBJECT_REDDRAGON, OBJECT_WHITEKEY,\r\n    0x00, 0x00\r\n];\r\n// Bat Object Matrix\r\nvar batMatrix = [\r\n    OBJECT_CHALISE,\r\n    OBJECT_SWORD,\r\n    OBJECT_BRIDGE,\r\n    OBJECT_YELLOWKEY,\r\n    OBJECT_WHITEKEY,\r\n    OBJECT_BLACKKEY,\r\n    OBJECT_REDDRAGON,\r\n    OBJECT_YELLOWDRAGON,\r\n    OBJECT_GREENDRAGON,\r\n    OBJECT_MAGNET,\r\n    0x00\r\n];\r\nfunction Adventure_Run() {\r\n    // read the console switches every frame\r\n    var reset = Object(_platform__WEBPACK_IMPORTED_MODULE_1__[\"Platform_ReadResetSwitch\"])();\r\n    var select = Object(_platform__WEBPACK_IMPORTED_MODULE_1__[\"Platform_ReadSelectSwitch\"])();\r\n    var switches = Object(_platform__WEBPACK_IMPORTED_MODULE_1__[\"Platform_ReadDifficultySwitches\"])();\r\n    gameDifficultyLeft = switches.left;\r\n    gameDifficultyRight = switches.right;\r\n    // Reset switch\r\n    if ((gameState != GAMESTATE_WIN) && switchReset && !reset) {\r\n        objectBall.room = 0x11; // Put us in the yellow castle\r\n        objectBall.x = 0x50 * 2; //\r\n        objectBall.y = 0x20 * 2; //\r\n        objectBall.previousX = objectBall.x;\r\n        objectBall.previousY = objectBall.y;\r\n        objectBall.linkedObject = OBJECT_NONE; // Not carrying anything\r\n        displayedRoomIndex = objectBall.room;\r\n        // Make the bat want something right away\r\n        batFedUpTimer = 0xff;\r\n        // Set up objects, rooms, and positions\r\n        if (gameState == GAMESTATE_GAMESELECT) {\r\n            // If started from the game selection screen, do a full init of level\r\n            SetupRoomObjects();\r\n        }\r\n        else {\r\n            // Else we just bring the dragons to life\r\n            objectDefs[OBJECT_YELLOWDRAGON].state = 0x0;\r\n            objectDefs[OBJECT_GREENDRAGON].state = 0x0;\r\n            objectDefs[OBJECT_REDDRAGON].state = 0x0;\r\n            objectDefs[OBJECT_YELLOWDRAGON].linkedObject = OBJECT_NONE;\r\n            objectDefs[OBJECT_GREENDRAGON].linkedObject = OBJECT_NONE;\r\n            objectDefs[OBJECT_REDDRAGON].linkedObject = OBJECT_NONE;\r\n        }\r\n        gameState = GAMESTATE_ACTIVE_1;\r\n    }\r\n    else {\r\n        // Is the game active?\r\n        if (gameState == GAMESTATE_GAMESELECT) {\r\n            objectDefs[OBJECT_NUMBER].state = gameLevel;\r\n            // Cycle through the game levels\r\n            if (switchSelect && !select) {\r\n                ++gameLevel;\r\n                if (gameLevel > 2)\r\n                    gameLevel = 0;\r\n            }\r\n            // Display the room and objects\r\n            displayedRoomIndex = 0;\r\n            objectBall.room = 0;\r\n            objectBall.x = 0;\r\n            objectBall.y = 0;\r\n            PrintDisplay();\r\n        }\r\n        else if (ISGAMEACTIVE()) {\r\n            // Get the room the chalise is in\r\n            // Is it in the yellow castle?\r\n            if (objectDefs[OBJECT_CHALISE].room == 0x12) {\r\n                // Go to won state\r\n                gameState = GAMESTATE_WIN;\r\n                winFlashTimer = 0xff;\r\n                // Play the sound\r\n                Object(_platform__WEBPACK_IMPORTED_MODULE_1__[\"Platform_MakeSound\"])(_constants__WEBPACK_IMPORTED_MODULE_0__[\"SOUND_WON\"]);\r\n            }\r\n            else if (switchSelect && !select) {\r\n                // Go to game level selection screen if select switch hit\r\n                gameState = GAMESTATE_GAMESELECT;\r\n                objectBall.room = 0;\r\n                objectBall.x = 0;\r\n                objectBall.y = 0;\r\n                objectBall.previousX = objectBall.x;\r\n                objectBall.previousY = objectBall.y;\r\n                displayedRoomIndex = objectBall.room;\r\n                // Setup the room and object\r\n                PrintDisplay();\r\n            }\r\n            else {\r\n                // Read joystick\r\n                Object(_platform__WEBPACK_IMPORTED_MODULE_1__[\"Platform_ReadJoystick\"])(joystick);\r\n                if (gameState == GAMESTATE_ACTIVE_1) {\r\n                    // Check ball collisions and move ball\r\n                    BallMovement();\r\n                    // Move the carried object\r\n                    MoveCarriedObject();\r\n                    // Setup the room and object\r\n                    PrintDisplay();\r\n                    ++gameState;\r\n                }\r\n                else if (gameState == GAMESTATE_ACTIVE_2) {\r\n                    // Deal with object pickup and putdown\r\n                    PickupPutdown();\r\n                    // Check ball collisions\r\n                    if (!objectBall.hitX && !objectBall.hitY) {\r\n                        // Make sure stuff we are carrying stays out of our way\r\n                        var hitObject = CollisionCheckBallWithObjects(0);\r\n                        if ((hitObject > OBJECT_NONE) && (hitObject == objectBall.linkedObject)) {\r\n                            var diffX = objectBall.x - objectBall.previousX;\r\n                            objectBall.linkedObjectX += diffX / 2;\r\n                            var diffY = objectBall.y - objectBall.previousY;\r\n                            objectBall.linkedObjectY += diffY / 2;\r\n                        }\r\n                    }\r\n                    if (objectBall.hitX) {\r\n                        if ((objectBall.hitObject > OBJECT_NONE) && (objectBall.hitObject == objectBall.linkedObject)) {\r\n                            var diffX = objectBall.x - objectBall.previousX;\r\n                            objectBall.linkedObjectX += diffX / 2;\r\n                        }\r\n                        objectBall.x = objectBall.previousX;\r\n                        objectBall.hitX = false;\r\n                    }\r\n                    if (objectBall.hitY) {\r\n                        if ((objectBall.hitObject > OBJECT_NONE) && (objectBall.hitObject == objectBall.linkedObject)) {\r\n                            var diffY = objectBall.y - objectBall.previousY;\r\n                            objectBall.linkedObjectY += diffY / 2;\r\n                        }\r\n                        objectBall.y = objectBall.previousY;\r\n                        objectBall.hitY = false;\r\n                    }\r\n                    // Increment the last object drawn\r\n                    ++displayListIndex;\r\n                    // deal with invisible surround moving\r\n                    Surround();\r\n                    // Move and deal with bat\r\n                    MoveBat();\r\n                    // Move and deal with portcullises\r\n                    Portals();\r\n                    // Display the room and objects\r\n                    PrintDisplay();\r\n                    ++gameState;\r\n                }\r\n                else if (gameState == GAMESTATE_ACTIVE_3) {\r\n                    // Move and deal with the green dragon\r\n                    MoveGreenDragon();\r\n                    // Move and deal with the yellow dragon\r\n                    MoveYellowDragon();\r\n                    // Move and deal with the red dragon\r\n                    MoveRedDragon();\r\n                    // Deal with the magnet\r\n                    Magnet();\r\n                    // Display the room and objects\r\n                    PrintDisplay();\r\n                    gameState = GAMESTATE_ACTIVE_1;\r\n                }\r\n            }\r\n        }\r\n        else if (gameState == GAMESTATE_WIN) {\r\n            if (winFlashTimer > 0) {\r\n                --winFlashTimer;\r\n            }\r\n            // Display the room and objects\r\n            PrintDisplay();\r\n            // Go to game selection screen on select or reset button\r\n            if ((switchReset && !reset) || (switchSelect && !select)) {\r\n                gameState = GAMESTATE_GAMESELECT;\r\n            }\r\n        }\r\n    }\r\n    switchReset = reset;\r\n    switchSelect = select;\r\n    AdvanceFlashColor();\r\n}\r\nfunction SetupRoomObjects() {\r\n    // Init all objects\r\n    for (var i_1 = 0; objectDefs[i_1].gfxData; i_1++) {\r\n        var object = objectDefs[i_1];\r\n        object.movementX = 0;\r\n        object.movementY = 0;\r\n        object.linkedObject = OBJECT_NONE;\r\n    }\r\n    // Read the object initialization table for the current game level\r\n    var p = (gameLevel == 0) ? game1Objects : game2Objects;\r\n    var i = 0;\r\n    while (p[i] != 0xff) {\r\n        var object = p[i++];\r\n        var room = p[i++];\r\n        var xpos = p[i++];\r\n        var ypos = p[i++];\r\n        var state = p[i++];\r\n        var movementX = p[i++];\r\n        var movementY = p[i++];\r\n        objectDefs[object].room = room;\r\n        objectDefs[object].x = xpos;\r\n        objectDefs[object].y = ypos;\r\n        objectDefs[object].state = state;\r\n        objectDefs[object].movementX = movementX;\r\n        objectDefs[object].movementY = movementY;\r\n    }\r\n    // Put objects in random rooms for level 3\r\n    if (gameLevel == 2) {\r\n        var boundsData = roomBoundsData;\r\n        var i_2 = 0;\r\n        var object = boundsData[i_2++];\r\n        var lower = boundsData[i_2++];\r\n        var upper = boundsData[i_2++];\r\n        do {\r\n            // pick a room between upper and lower bounds (inclusive)\r\n            while (1) {\r\n                var room = Object(_platform__WEBPACK_IMPORTED_MODULE_1__[\"Platform_Random\"])() * 0x1f;\r\n                if (room >= lower && room <= upper) {\r\n                    objectDefs[object].room = room;\r\n                    break;\r\n                }\r\n            }\r\n            object = boundsData[i_2++];\r\n            lower = boundsData[i_2++];\r\n            upper = boundsData[i_2++];\r\n        } while (object > OBJECT_NONE);\r\n    }\r\n}\r\nfunction BallMovement() {\r\n    // store the existing ball location\r\n    var tempX = objectBall.x;\r\n    var tempY = objectBall.y;\r\n    var eaten = ((objectDefs[OBJECT_YELLOWDRAGON].linkedObject == OBJECT_BALL)\r\n        || (objectDefs[OBJECT_GREENDRAGON].linkedObject == OBJECT_BALL)\r\n        || (objectDefs[OBJECT_REDDRAGON].linkedObject == OBJECT_BALL));\r\n    // mark the existing Y location as the previous Y location\r\n    objectBall.previousY = objectBall.y;\r\n    objectBall.hitObject = OBJECT_NONE;\r\n    displayedRoomIndex = objectBall.room;\r\n    // Move the ball on the Y axis\r\n    if (joystick.up)\r\n        objectBall.y += 6;\r\n    if (joystick.down)\r\n        objectBall.y -= 6;\r\n    if (!eaten) {\r\n        // Wrap rooms in Y if necessary\r\n        if (objectBall.y > (_constants__WEBPACK_IMPORTED_MODULE_0__[\"ADVENTURE_OVERSCAN\"] + _constants__WEBPACK_IMPORTED_MODULE_0__[\"ADVENTURE_SCREEN_HEIGHT\"]) + 6) {\r\n            // Wrap the ball to the bottom of the screen\r\n            objectBall.y = _constants__WEBPACK_IMPORTED_MODULE_0__[\"ADVENTURE_OVERSCAN\"] + _constants__WEBPACK_IMPORTED_MODULE_0__[\"ADVENTURE_OVERSCAN\"] - 2;\r\n            objectBall.previousY = objectBall.y;\r\n            // Set the new room\r\n            var currentRoom = roomDefs[objectBall.room];\r\n            objectBall.room = currentRoom.roomUp;\r\n            objectBall.room = AdjustRoomLevel(objectBall.room);\r\n        }\r\n        else if (objectBall.y < 0x0D * 2) {\r\n            // Handle ball leaving the castles\r\n            if (objectBall.room == entryRoomOffsets[OBJECT_PORT1]) {\r\n                objectBall.x = 0xA0;\r\n                objectBall.y = 0x2C * 2;\r\n                objectBall.previousX = objectBall.x;\r\n                objectBall.previousY = objectBall.y;\r\n                objectBall.room = castleRoomOffsets[OBJECT_PORT1];\r\n                objectBall.room = AdjustRoomLevel(objectBall.room);\r\n            }\r\n            else if (objectBall.room == entryRoomOffsets[OBJECT_PORT2]) {\r\n                objectBall.x = 0xA0;\r\n                objectBall.y = 0x2C * 2;\r\n                objectBall.previousX = objectBall.x;\r\n                objectBall.previousY = objectBall.y;\r\n                objectBall.room = castleRoomOffsets[OBJECT_PORT2];\r\n                objectBall.room = AdjustRoomLevel(objectBall.room);\r\n            }\r\n            else if (objectBall.room == entryRoomOffsets[OBJECT_PORT3]) {\r\n                objectBall.x = 0xA0;\r\n                objectBall.y = 0x2C * 2;\r\n                objectBall.previousX = objectBall.x;\r\n                objectBall.previousY = objectBall.y;\r\n                objectBall.room = castleRoomOffsets[OBJECT_PORT3];\r\n                objectBall.room = AdjustRoomLevel(objectBall.room);\r\n            }\r\n            else {\r\n                // Just lookup the next room down and switch to that room\r\n                // Wrap the ball to the top of the screen\r\n                var newY = (_constants__WEBPACK_IMPORTED_MODULE_0__[\"ADVENTURE_SCREEN_HEIGHT\"] + _constants__WEBPACK_IMPORTED_MODULE_0__[\"ADVENTURE_OVERSCAN\"]);\r\n                var currentRoom = roomDefs[objectBall.room];\r\n                var roomDown = AdjustRoomLevel(currentRoom.roomDown);\r\n                if (CollisionCheckBallWithWalls(roomDown, tempX, newY)) {\r\n                    // We've hit a wall on the next screen\r\n                    objectBall.hitY = true;\r\n                    displayedRoomIndex = roomDown;\r\n                }\r\n                else {\r\n                    // Set the new room\r\n                    objectBall.y = newY;\r\n                    objectBall.room = roomDown;\r\n                }\r\n            }\r\n        }\r\n        // Collision check the ball with the new Y coordinate against walls and objects\r\n        // For collisions with objects, we only care about hitting non-carryable objects at this point\r\n        var hitObject = CollisionCheckBallWithObjects(0);\r\n        var crossingBridge = CrossingBridge(objectBall.room, tempX, objectBall.y); // PDHTODO IS THIS USED??\r\n        var hitWall = crossingBridge ? false : CollisionCheckBallWithWalls(objectBall.room, tempX, objectBall.y);\r\n        if (hitWall || (hitObject > OBJECT_NONE)) {\r\n            // Hit a wall or non-carryable object\r\n            objectBall.hitY = true;\r\n            objectBall.hitObject = hitObject;\r\n        }\r\n    }\r\n    else {\r\n        objectBall.hitY = true;\r\n    }\r\n    // mark the existing X location as the previous X location\r\n    objectBall.previousX = objectBall.x;\r\n    // Move the ball on the X axis\r\n    if (joystick.right)\r\n        objectBall.x += 6;\r\n    if (joystick.left)\r\n        objectBall.x -= 6;\r\n    if (!eaten) {\r\n        // Wrap rooms in X if necessary\r\n        if (objectBall.x >= (_constants__WEBPACK_IMPORTED_MODULE_0__[\"ADVENTURE_SCREEN_WIDTH\"] - 4)) {\r\n            // Wrap the ball to the left side of the screen\r\n            objectBall.x = 5;\r\n            // Is it room #3 (Right to secret room)\r\n            if (objectBall.room == 0x3) {\r\n                // Set room to secret room\r\n                objectBall.room = 0x1e;\r\n            }\r\n            else {\r\n                // Set the new room\r\n                var currentRoom = roomDefs[objectBall.room];\r\n                objectBall.room = currentRoom.roomRight;\r\n            }\r\n            objectBall.room = AdjustRoomLevel(objectBall.room);\r\n        }\r\n        else if (objectBall.x < 4) {\r\n            // Wrap the ball to the right side of the screen\r\n            objectBall.x = _constants__WEBPACK_IMPORTED_MODULE_0__[\"ADVENTURE_SCREEN_WIDTH\"] - 5;\r\n            // Set the new room\r\n            var currentRoom = roomDefs[objectBall.room];\r\n            objectBall.room = currentRoom.roomLeft;\r\n            objectBall.room = AdjustRoomLevel(objectBall.room);\r\n        }\r\n        // Collision check the ball with the new Y coordinate against walls and objects\r\n        // For collisions with objects, we only care about hitting non-carryable objects at this point\r\n        var hitObject = CollisionCheckBallWithObjects(0);\r\n        var hitWall = CollisionCheckBallWithWalls(objectBall.room, objectBall.x, tempY);\r\n        if (hitWall || (hitObject > OBJECT_NONE)) {\r\n            // Hit a wall or non-carryable object\r\n            objectBall.hitX = true;\r\n            objectBall.hitObject = hitObject;\r\n        }\r\n    }\r\n    else {\r\n        objectBall.hitX = true;\r\n    }\r\n}\r\nfunction MoveCarriedObject() {\r\n    if (objectBall.linkedObject >= 0) {\r\n        var object = objectDefs[objectBall.linkedObject];\r\n        object.x = (objectBall.x / 2) + objectBall.linkedObjectX;\r\n        object.y = (objectBall.y / 2) + objectBall.linkedObjectY;\r\n        object.room = objectBall.room;\r\n    }\r\n    // Seems like a weird place to call this but this matches the original game\r\n    MoveGroundObject();\r\n}\r\nfunction MoveGroundObject() {\r\n    var port1 = objectDefs[OBJECT_PORT1];\r\n    var port2 = objectDefs[OBJECT_PORT2];\r\n    var port3 = objectDefs[OBJECT_PORT3];\r\n    // Handle ball going into the castles\r\n    if (objectBall.room == port1.room && port1.state != 0x0C && CollisionCheckObject(port1, (objectBall.x - 4), (objectBall.y - 1), 8, 8)) {\r\n        objectBall.room = entryRoomOffsets[OBJECT_PORT1];\r\n        objectBall.y = _constants__WEBPACK_IMPORTED_MODULE_0__[\"ADVENTURE_OVERSCAN\"] + _constants__WEBPACK_IMPORTED_MODULE_0__[\"ADVENTURE_OVERSCAN\"] - 2;\r\n        objectBall.previousY = objectBall.y;\r\n        port1.state = 0; // make sure it stays unlocked in case we are walking in with the key\r\n    }\r\n    else if (objectBall.room == port2.room && port2.state != 0x0C && CollisionCheckObject(port2, (objectBall.x - 4), (objectBall.y - 1), 8, 8)) {\r\n        objectBall.room = entryRoomOffsets[OBJECT_PORT2];\r\n        objectBall.y = _constants__WEBPACK_IMPORTED_MODULE_0__[\"ADVENTURE_OVERSCAN\"] + _constants__WEBPACK_IMPORTED_MODULE_0__[\"ADVENTURE_OVERSCAN\"] - 2;\r\n        objectBall.previousY = objectBall.y;\r\n        port2.state = 0; // make sure it stays unlocked in case we are walking in with the key\r\n    }\r\n    else if (objectBall.room == port3.room && port3.state != 0x0C && CollisionCheckObject(port3, (objectBall.x - 4), (objectBall.y - 1), 8, 8)) {\r\n        objectBall.room = entryRoomOffsets[OBJECT_PORT3];\r\n        objectBall.y = _constants__WEBPACK_IMPORTED_MODULE_0__[\"ADVENTURE_OVERSCAN\"] + _constants__WEBPACK_IMPORTED_MODULE_0__[\"ADVENTURE_OVERSCAN\"] - 2;\r\n        objectBall.previousY = objectBall.y;\r\n        port3.state = 0; // make sure it stays unlocked in case we are walking in with the key\r\n    }\r\n    // Move any objects that need moving, and wrap objects from room to room\r\n    for (var i = OBJECT_REDDRAGON; objectDefs[i].gfxData; i++) {\r\n        var object = objectDefs[i];\r\n        // For some reason on game level 3 the object room becomes a foating point number\r\n        // Need to figure out why...for now this fixes it \r\n        object.room = Math.round(object.room);\r\n        // Apply movement\r\n        object.x += object.movementX;\r\n        object.y += object.movementY;\r\n        // Check and Deal with Up\r\n        if (object.y > 0x6A) {\r\n            object.y = 0x0D;\r\n            object.room = AdjustRoomLevel(roomDefs[object.room].roomUp);\r\n        }\r\n        // Check and Deal with Left\r\n        if (object.x < 0x03) {\r\n            object.x = 0x9A;\r\n            object.room = AdjustRoomLevel(roomDefs[object.room].roomLeft);\r\n        }\r\n        // Check and Deal with Down\r\n        if (object.y < 0x0D) {\r\n            // Handle object leaving the castles\r\n            if (object.room == entryRoomOffsets[OBJECT_PORT1]) {\r\n                object.y = 0x5C;\r\n                object.room = AdjustRoomLevel(castleRoomOffsets[OBJECT_PORT1]);\r\n            }\r\n            else if (object.room == entryRoomOffsets[OBJECT_PORT2]) {\r\n                object.y = 0x5C;\r\n                object.room = AdjustRoomLevel(castleRoomOffsets[OBJECT_PORT2]);\r\n            }\r\n            else if (object.room == entryRoomOffsets[OBJECT_PORT3]) {\r\n                object.y = 0x5C;\r\n                object.room = AdjustRoomLevel(castleRoomOffsets[OBJECT_PORT3]);\r\n            }\r\n            else {\r\n                object.y = 0x69;\r\n                object.room = AdjustRoomLevel(roomDefs[object.room].roomDown);\r\n            }\r\n        }\r\n        // Check and Deal with Right\r\n        if (object.x > 0x9B) {\r\n            object.x = 0x03;\r\n            object.room = AdjustRoomLevel(roomDefs[object.room].roomRight);\r\n        }\r\n        // Move the linked object\r\n        if (object.linkedObject > OBJECT_NONE) {\r\n            var linkedObj = objectDefs[object.linkedObject];\r\n            linkedObj.x = object.x + object.linkedObjectX;\r\n            linkedObj.y = object.y + object.linkedObjectY;\r\n            linkedObj.room = object.room;\r\n        }\r\n    }\r\n}\r\nfunction PrintDisplay() {\r\n    // get the playfield data\r\n    var displayedRoom = displayedRoomIndex;\r\n    var currentRoom = roomDefs[displayedRoom];\r\n    var roomData = currentRoom.graphicsData;\r\n    // get the playfield color\r\n    var color = ((gameState == GAMESTATE_WIN) && (winFlashTimer > 0)) ? GetFlashColor() : colorTable[currentRoom.color];\r\n    var colorBackground = colorTable[COLOR_LTGRAY];\r\n    // Fill the entire backbuffer with the playfield background color before we draw anything else\r\n    Object(_platform__WEBPACK_IMPORTED_MODULE_1__[\"Platform_PaintPixel\"])(colorBackground.r, colorBackground.g, colorBackground.b, 0, 0, _constants__WEBPACK_IMPORTED_MODULE_0__[\"ADVENTURE_SCREEN_WIDTH\"], _constants__WEBPACK_IMPORTED_MODULE_0__[\"ADVENTURE_TOTAL_SCREEN_HEIGHT\"]);\r\n    // paint the surround under the playfield layer\r\n    if ((objectSurround.room == objectBall.room) && (objectSurround.state == 0))\r\n        DrawObject(objectSurround);\r\n    // get the playfield mirror flag\r\n    var mirror = currentRoom.flags & ROOMFLAG_MIRROR;\r\n    //\r\n    // Extract the playfield register bits and paint the playfield\r\n    // The playfied register is 20 bits wide encoded across 3 bytes\r\n    // as follows:\r\n    //    PF0   |  PF1   |  PF2\r\n    //  xxxx4567|76543210|01234567\r\n    // Each set bit indicates playfield color - else background color -\r\n    // the size of each block is 8 x 32, and the drawing is shifted\r\n    // upwards by 16 pixels\r\n    //\r\n    var pfRegisterWidth = 20;\r\n    // mask values for playfield bits\r\n    var shiftreg = [\r\n        0x10, 0x20, 0x40, 0x80,\r\n        0x80, 0x40, 0x20, 0x10, 0x8, 0x4, 0x2, 0x1,\r\n        0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80\r\n    ];\r\n    // each cell is 8 x 32\r\n    var cell_width = 8;\r\n    var cell_height = 32;\r\n    // draw the playfield\r\n    for (var cy = 0; cy <= 6; cy++) {\r\n        var pf0 = roomData[(cy * 3) + 0];\r\n        var pf1 = roomData[(cy * 3) + 1];\r\n        var pf2 = roomData[(cy * 3) + 2];\r\n        var ypos = 6 - cy;\r\n        for (var cx = 0; cx < pfRegisterWidth; cx++) {\r\n            var bit = false;\r\n            if (cx < 4)\r\n                bit = (pf0 & shiftreg[cx]) ? true : false;\r\n            else if (cx < 12)\r\n                bit = (pf1 & shiftreg[cx]) ? true : false;\r\n            else\r\n                bit = (pf2 & shiftreg[cx]) ? true : false;\r\n            if (bit) {\r\n                Object(_platform__WEBPACK_IMPORTED_MODULE_1__[\"Platform_PaintPixel\"])(color.r, color.g, color.b, cx * cell_width, ypos * cell_height, cell_width, cell_height);\r\n                if (mirror)\r\n                    Object(_platform__WEBPACK_IMPORTED_MODULE_1__[\"Platform_PaintPixel\"])(color.r, color.g, color.b, (cx + 20) * cell_width, ypos * cell_height, cell_width, cell_height);\r\n                else\r\n                    Object(_platform__WEBPACK_IMPORTED_MODULE_1__[\"Platform_PaintPixel\"])(color.r, color.g, color.b, ((40 - (cx + 1)) * cell_width), ypos * cell_height, cell_width, cell_height);\r\n            }\r\n        }\r\n    }\r\n    //\r\n    // Draw the ball object\r\n    //\r\n    color = colorTable[roomDefs[displayedRoomIndex].color];\r\n    var x = (objectBall.x - 4) & ~0x00000001;\r\n    var y = (objectBall.y - 10) & ~0x00000001;\r\n    Object(_platform__WEBPACK_IMPORTED_MODULE_1__[\"Platform_PaintPixel\"])(color.r, color.g, color.b, x, y, 8, 8);\r\n    //\r\n    // Draw any objects in the room\r\n    //\r\n    DrawObjects(displayedRoom);\r\n}\r\nfunction PickupPutdown() {\r\n    if (joystick.fire && (objectBall.linkedObject >= 0)) {\r\n        // Put down the current object!\r\n        objectBall.linkedObject = OBJECT_NONE;\r\n        // Play the sound\r\n        Object(_platform__WEBPACK_IMPORTED_MODULE_1__[\"Platform_MakeSound\"])(_constants__WEBPACK_IMPORTED_MODULE_0__[\"SOUND_PUTDOWN\"]);\r\n    }\r\n    else {\r\n        // See if we are touching any carryable objects\r\n        var hitIndex = CollisionCheckBallWithObjects(OBJECT_SWORD);\r\n        if (hitIndex > OBJECT_NONE) {\r\n            // Ignore the object we are already carrying\r\n            if (hitIndex == objectBall.linkedObject) {\r\n                // Check the remainder of the objects\r\n                hitIndex = CollisionCheckBallWithObjects(hitIndex + 1);\r\n            }\r\n            if (hitIndex > OBJECT_NONE) {\r\n                // Pick up this object!\r\n                objectBall.linkedObject = hitIndex;\r\n                // calculate the XY offsets from the ball's position\r\n                objectBall.linkedObjectX = objectDefs[hitIndex].x - (objectBall.x / 2);\r\n                objectBall.linkedObjectY = objectDefs[hitIndex].y - (objectBall.y / 2);\r\n                // Play the sound\r\n                Object(_platform__WEBPACK_IMPORTED_MODULE_1__[\"Platform_MakeSound\"])(_constants__WEBPACK_IMPORTED_MODULE_0__[\"SOUND_PICKUP\"]);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction Surround() {\r\n    // get the playfield data\r\n    var currentRoom = roomDefs[objectBall.room];\r\n    if (currentRoom.color == COLOR_LTGRAY) {\r\n        // Put it in the same room as the ball (player) and center it under the ball\r\n        objectSurround.room = objectBall.room;\r\n        objectSurround.x = (objectBall.x - 0x1E) / 2;\r\n        objectSurround.y = (objectBall.y + 0x18) / 2;\r\n    }\r\n    else {\r\n        objectSurround.room = -1;\r\n    }\r\n}\r\nvar flapTimer = 0;\r\nfunction MoveBat() {\r\n    var bat = objectDefs[OBJECT_BAT];\r\n    if (++flapTimer >= 0x04) {\r\n        bat.state = (bat.state == 0) ? 1 : 0;\r\n        flapTimer = 0;\r\n    }\r\n    if ((bat.linkedObject != OBJECT_NONE) && (batFedUpTimer < 0xff))\r\n        ++batFedUpTimer;\r\n    if (batFedUpTimer >= 0xff) {\r\n        // Get the bat's current extents\r\n        var batExtent = CalcPlayerSpriteExtents(bat);\r\n        // Enlarge the bat extent by 7 pixels for the proximity checks below\r\n        // (doing the bat once is faster than doing each object and the results are the same)\r\n        batExtent.x -= 7;\r\n        batExtent.y -= 7;\r\n        batExtent.w += 7 * 2;\r\n        batExtent.h += 7 * 2;\r\n        // Go through the bat's object matrix\r\n        var matrixP = batMatrix;\r\n        var i = 0;\r\n        do {\r\n            // Get the object it is seeking\r\n            var seekObject = objectDefs[matrixP[i]];\r\n            if ((seekObject.room == bat.room) && (bat.linkedObject != matrixP[i])) {\r\n                var seekX = seekObject.x;\r\n                var seekY = seekObject.y;\r\n                // Set the movement\r\n                // horizontal axis\r\n                if (bat.x < seekX) {\r\n                    bat.movementX = 3;\r\n                }\r\n                else if (bat.x > seekX) {\r\n                    bat.movementX = -3;\r\n                }\r\n                else\r\n                    bat.movementX = 0;\r\n                // vertical axis\r\n                if (bat.y < seekY) {\r\n                    bat.movementY = 3;\r\n                }\r\n                else if (bat.y > seekY) {\r\n                    bat.movementY = -3;\r\n                }\r\n                else\r\n                    bat.movementY = 0;\r\n                // If the bat is within 7 pixels of the seek object it can pick the object up\r\n                // The bat extents have already been expanded by 7 pixels above, so a simple\r\n                // rectangle intersection test is good enought here\r\n                var objExtent = CalcPlayerSpriteExtents(seekObject);\r\n                if (HitTestRects(batExtent.x, batExtent.y, batExtent.w, batExtent.h, objExtent.x, objExtent.y, objExtent.w, objExtent.h)) {\r\n                    // Hit something we want\r\n                    // If the bat grabs something that the ball is carrying, the bat gets it\r\n                    // This allows the bat to take something we are carrying\r\n                    if (matrixP[i] == objectBall.linkedObject) {\r\n                        // Now we have nothing\r\n                        objectBall.linkedObject = OBJECT_NONE;\r\n                    }\r\n                    // Pick it up\r\n                    bat.linkedObject = matrixP[i];\r\n                    bat.linkedObjectX = 8;\r\n                    bat.linkedObjectY = 0;\r\n                    // Reset the timer\r\n                    batFedUpTimer = 0;\r\n                }\r\n                // break since we found something\r\n                break;\r\n            }\r\n        } while (matrixP[++i]);\r\n    }\r\n}\r\nfunction Portals() {\r\n    var port1 = objectDefs[OBJECT_PORT1];\r\n    var port2 = objectDefs[OBJECT_PORT2];\r\n    var port3 = objectDefs[OBJECT_PORT3];\r\n    var yellowKey = objectDefs[OBJECT_YELLOWKEY];\r\n    var whiteKey = objectDefs[OBJECT_WHITEKEY];\r\n    var blackKey = objectDefs[OBJECT_BLACKKEY];\r\n    if ((port1.room == objectBall.room) && (yellowKey.room == objectBall.room) && (port1.state == 0 || port1.state == 12)) {\r\n        // Toggle the port state\r\n        if (CollisionCheckObjectObject(port1, yellowKey))\r\n            port1.state++;\r\n    }\r\n    if (port1.state != 0 && port1.state != 12) {\r\n        // Raise/lower the port\r\n        port1.state++;\r\n    }\r\n    if (port1.state > 22) {\r\n        // Port 1 is unlocked\r\n        port1.state = 0;\r\n        roomDefs[entryRoomOffsets[OBJECT_PORT1]].roomDown = castleRoomOffsets[OBJECT_PORT1];\r\n    }\r\n    else if (port1.state == 12) {\r\n        // Port 1 is locked\r\n        roomDefs[entryRoomOffsets[OBJECT_PORT1]].roomDown = entryRoomOffsets[OBJECT_PORT1];\r\n    }\r\n    if ((port2.room == objectBall.room) && (whiteKey.room == objectBall.room) && (port2.state == 0 || port2.state == 12)) {\r\n        // Toggle the port state\r\n        if (CollisionCheckObjectObject(port2, whiteKey))\r\n            port2.state++;\r\n    }\r\n    if (port2.state != 0 && port2.state != 12) {\r\n        // Raise/lower the port\r\n        port2.state++;\r\n    }\r\n    if (port2.state > 22) {\r\n        // Port 2 is unlocked\r\n        port2.state = 0;\r\n        roomDefs[entryRoomOffsets[OBJECT_PORT2]].roomDown = castleRoomOffsets[OBJECT_PORT2];\r\n    }\r\n    else if (port2.state == 12) {\r\n        // Port 2 is locked\r\n        roomDefs[entryRoomOffsets[OBJECT_PORT2]].roomDown = entryRoomOffsets[OBJECT_PORT2];\r\n    }\r\n    if ((port3.room == objectBall.room) && (blackKey.room == objectBall.room) && (port3.state == 0 || port3.state == 12)) {\r\n        // Toggle the port state\r\n        if (CollisionCheckObjectObject(port3, blackKey))\r\n            port3.state++;\r\n    }\r\n    if (port3.state != 0 && port3.state != 12) {\r\n        // Raise/lower the port\r\n        port3.state++;\r\n    }\r\n    if (port3.state > 22) {\r\n        // Port 3 is unlocked\r\n        port3.state = 0;\r\n        roomDefs[entryRoomOffsets[OBJECT_PORT3]].roomDown = castleRoomOffsets[OBJECT_PORT3];\r\n    }\r\n    else if (port3.state == 12) {\r\n        // Port 3 is locked\r\n        roomDefs[entryRoomOffsets[OBJECT_PORT3]].roomDown = entryRoomOffsets[OBJECT_PORT3];\r\n    }\r\n}\r\nvar greenDragonTimer = 0;\r\nfunction MoveGreenDragon() {\r\n    greenDragonTimer = MoveDragon(objectDefs[OBJECT_GREENDRAGON], greenDragonMatrix, 2, greenDragonTimer);\r\n}\r\nvar yellowDragonTimer = 0;\r\nfunction MoveYellowDragon() {\r\n    yellowDragonTimer = MoveDragon(objectDefs[OBJECT_YELLOWDRAGON], yellowDragonMatrix, 2, yellowDragonTimer);\r\n}\r\nvar redDragonTimer = 0;\r\nfunction MoveRedDragon() {\r\n    redDragonTimer = MoveDragon(objectDefs[OBJECT_REDDRAGON], redDragonMatrix, 3, redDragonTimer);\r\n}\r\nfunction MoveDragon(dragon, matrix, speed, timer) {\r\n    if (dragon.state == 0) {\r\n        // Has the Ball hit the Dragon?\r\n        if ((objectBall.room == dragon.room) && CollisionCheckObject(dragon, (objectBall.x - 4), (objectBall.y - 4), 8, 8)) {\r\n            // Set the State to 03 (roar)\r\n            dragon.state = 3;\r\n            // Set the timer based on the game level and difficulty setting\r\n            timer = 0xFC - dragonDiff[(gameLevel * 2) + ((gameDifficultyLeft == DIFFICULTY_A) ? 1 : 0)];\r\n            // Set the dragon's position to the same as the ball\r\n            dragon.x = objectBall.x / 2;\r\n            dragon.y = objectBall.y / 2;\r\n            dragon.movementX = 0;\r\n            dragon.movementY = 0;\r\n            // Play the sound\r\n            Object(_platform__WEBPACK_IMPORTED_MODULE_1__[\"Platform_MakeSound\"])(_constants__WEBPACK_IMPORTED_MODULE_0__[\"SOUND_ROAR\"]);\r\n        }\r\n        // Has the Sword hit the Dragon?\r\n        if (CollisionCheckObjectObject(dragon, objectDefs[OBJECT_SWORD])) {\r\n            // Set the State to 01 (Dead)\r\n            dragon.state = 1;\r\n            dragon.movementX = 0;\r\n            dragon.movementY = 0;\r\n            // Play the sound\r\n            Object(_platform__WEBPACK_IMPORTED_MODULE_1__[\"Platform_MakeSound\"])(_constants__WEBPACK_IMPORTED_MODULE_0__[\"SOUND_DRAGONDIE\"]);\r\n        }\r\n        if (dragon.state == 0) // PDHTODO - REMOVE - NOT NEEDED\r\n         {\r\n            // Go through the dragon's object matrix\r\n            // Difficulty switch determines flee or don't flee from sword\r\n            var matrixP = matrix;\r\n            var i = (gameDifficultyRight == DIFFICULTY_B) ? 0 : 2;\r\n            do {\r\n                var seekDir = 0; // 1 is seeking, -1 is fleeing\r\n                var seekX = 0, seekY = 0;\r\n                var fleeObject = matrixP[i + 0];\r\n                var seekObject = matrixP[i + 1];\r\n                // Dragon fleeing an object\r\n                if ((fleeObject > OBJECT_NONE) && objectDefs[fleeObject] != dragon) {\r\n                    // get the object it is fleeing\r\n                    var object = objectDefs[fleeObject];\r\n                    if (object.room == dragon.room) {\r\n                        seekDir = -1;\r\n                        seekX = object.x;\r\n                        seekY = object.y;\r\n                    }\r\n                }\r\n                else {\r\n                    // Dragon seeking the ball\r\n                    if (seekDir == 0) {\r\n                        if (matrixP[i + 1] == OBJECT_BALL) {\r\n                            if (objectBall.room == dragon.room) {\r\n                                seekDir = 1;\r\n                                seekX = objectBall.x / 2;\r\n                                seekY = objectBall.y / 2;\r\n                            }\r\n                        }\r\n                    }\r\n                    // Dragon seeking an object\r\n                    if ((seekDir == 0) && (seekObject > OBJECT_NONE)) {\r\n                        // Get the object it is seeking\r\n                        var object = objectDefs[seekObject];\r\n                        if (object.room == dragon.room) {\r\n                            seekDir = 1;\r\n                            seekX = object.x;\r\n                            seekY = object.y;\r\n                        }\r\n                    }\r\n                }\r\n                // Move the dragon\r\n                if ((seekDir > 0) || (seekDir < 0)) {\r\n                    dragon.movementX = 0;\r\n                    dragon.movementY = 0;\r\n                    // horizontal axis\r\n                    if (dragon.x < seekX) {\r\n                        dragon.movementX = seekDir * speed;\r\n                    }\r\n                    else if (dragon.x > seekX) {\r\n                        dragon.movementX = -(seekDir * speed);\r\n                    }\r\n                    // vertical axis\r\n                    if (dragon.y < seekY) {\r\n                        dragon.movementY = seekDir * speed;\r\n                    }\r\n                    else if (dragon.y > seekY) {\r\n                        dragon.movementY = -(seekDir * speed);\r\n                    }\r\n                    // Found something - we're done\r\n                    return;\r\n                }\r\n            } while (matrixP[i += 2]);\r\n        }\r\n    }\r\n    else if (dragon.state == 2) {\r\n        // Eaten\r\n        objectBall.room = dragon.room;\r\n        objectBall.x = (dragon.x + 3) * 2;\r\n        objectBall.y = (dragon.y - 10) * 2;\r\n        dragon.movementX = 0;\r\n        dragon.movementY = 0;\r\n        displayedRoomIndex = objectBall.room;\r\n    }\r\n    else if (dragon.state == 3) {\r\n        --timer;\r\n        if (timer <= 0) {\r\n            // Has the Ball hit the Dragon?\r\n            if ((objectBall.room == dragon.room) && CollisionCheckObject(dragon, (objectBall.x - 4), (objectBall.y - 1), 8, 8)) {\r\n                // Set the State to 01 (eaten)\r\n                dragon.linkedObject = OBJECT_BALL;\r\n                dragon.state = 2;\r\n                // Play the sound\r\n                Object(_platform__WEBPACK_IMPORTED_MODULE_1__[\"Platform_MakeSound\"])(_constants__WEBPACK_IMPORTED_MODULE_0__[\"SOUND_EATEN\"]);\r\n            }\r\n            else {\r\n                // Go back to stalking\r\n                dragon.state = 0;\r\n            }\r\n        }\r\n    }\r\n    // else dead!\r\n    return timer;\r\n}\r\nfunction Magnet() {\r\n    var magnet = objectDefs[OBJECT_MAGNET];\r\n    var i = 0;\r\n    while (magnetMatrix[i]) {\r\n        // Look for items in the magnet matrix that are in the same room as the magnet\r\n        var object = objectDefs[magnetMatrix[i]];\r\n        if ((magnetMatrix[i] != objectBall.linkedObject) && (object.room == magnet.room)) {\r\n            // horizontal axis\r\n            if (object.x < magnet.x)\r\n                object.x++;\r\n            else if (object.x > magnet.x)\r\n                object.x--;\r\n            // vertical axis - offset by the height of the magnet so items stick to the \"bottom\"\r\n            if (object.y < (magnet.y - magnet.gfxData[0]))\r\n                object.y++;\r\n            else if (object.y > (magnet.y - magnet.gfxData[0]))\r\n                object.y--;\r\n            // Only attract the first item found in the matrix\r\n            break;\r\n        }\r\n        ++i;\r\n    }\r\n}\r\nfunction AdjustRoomLevel(room) {\r\n    // If the the room number is above 0x80 it changes based on the game level\r\n    if (room & 0x80) {\r\n        // Remove the 0x80 flag and add the level number to get the offset into the room delta table\r\n        var newRoomIndex = (room & ~0x80) + gameLevel;\r\n        room = roomLevelDiffs[newRoomIndex];\r\n    }\r\n    return room;\r\n}\r\nfunction DrawObjects(room) {\r\n    // Clear out the display list\r\n    var displayList = [];\r\n    for (var i_3 = 0; i_3 < MAX_OBJECTS; i_3++) {\r\n        displayList.push(OBJECT_NONE);\r\n    }\r\n    // Create a list of all the objects that want to be drawn\r\n    var numAdded = 0;\r\n    if (objectSurround.room == room)\r\n        displayList[numAdded++] = OBJECT_SURROUND;\r\n    var colorFirst = -1;\r\n    var colorLast = -1;\r\n    for (var i_4 = 0; objectDefs[i_4].gfxData; i_4++) {\r\n        // Init it to not displayed\r\n        objectDefs[i_4].displayed = false;\r\n        if (objectDefs[i_4].room == room) {\r\n            // This object is in the current room - add it to the list\r\n            displayList[numAdded++] = i_4;\r\n            if (colorFirst < 0)\r\n                colorFirst = objectDefs[i_4].color;\r\n            colorLast = objectDefs[i_4].color;\r\n        }\r\n    }\r\n    // Now display the objects in the list, up to the max number of objects at a time\r\n    if (numAdded <= maxDisplayableObjects)\r\n        displayListIndex = 0;\r\n    else {\r\n        if (displayListIndex > numAdded)\r\n            displayListIndex = 0;\r\n        if (displayListIndex > MAX_OBJECTS)\r\n            displayListIndex = 0;\r\n        if (displayList[displayListIndex] == OBJECT_NONE)\r\n            displayListIndex = 0;\r\n    }\r\n    objectSurround.displayed = false;\r\n    var numDisplayed = 0;\r\n    var i = displayListIndex;\r\n    if (showObjectFlicker) {\r\n        //\r\n        // If more than maxDisplayableObjects are needed to be drawn, we multiplex/cycle through them\r\n        // Note that this also (intentionally) effects collision checking, as per the original game!!\r\n        //\r\n        while ((numDisplayed++) < numAdded && (numDisplayed <= maxDisplayableObjects)) {\r\n            if (displayList[i] > OBJECT_NONE) {\r\n                DrawObject(objectDefs[displayList[i]]);\r\n                objectDefs[displayList[i]].displayed = true;\r\n                colorLast = objectDefs[displayList[i]].color;\r\n            }\r\n            else if (displayList[i] == OBJECT_SURROUND) {\r\n                objectSurround.displayed = true;\r\n            }\r\n            // wrap to the beginning of the list if we've reached the end\r\n            ++i;\r\n            if (i > MAX_OBJECTS)\r\n                i = 0;\r\n            else if (displayList[i] == OBJECT_NONE)\r\n                i = 0;\r\n        }\r\n    }\r\n    else {\r\n        //\r\n        // We still need to keep the displayed flags up to date for proper collision checking\r\n        //\r\n        while ((numDisplayed++) < numAdded && (numDisplayed <= maxDisplayableObjects)) {\r\n            if (displayList[i] > OBJECT_NONE) {\r\n                objectDefs[displayList[i]].displayed = true;\r\n                colorLast = objectDefs[displayList[i]].color;\r\n            }\r\n            else if (displayList[i] == OBJECT_SURROUND) {\r\n                objectSurround.displayed = true;\r\n            }\r\n            // wrap to the beginning of the list if we've reached the end\r\n            ++i;\r\n            if (i > MAX_OBJECTS)\r\n                i = 0;\r\n            else if (displayList[i] == OBJECT_NONE)\r\n                i = 0;\r\n        }\r\n        // Now just paint everything in this room so we bypass the flicker if desired\r\n        for (var i_5 = 0; objectDefs[i_5].gfxData; i_5++) {\r\n            if (objectDefs[i_5].room == room)\r\n                DrawObject(objectDefs[i_5]);\r\n        }\r\n    }\r\n    if (roomDefs[room].flags & ROOMFLAG_LEFTTHINWALL) {\r\n        // Position missile 00 to 0D,00 - left thin wall\r\n        var color = colorTable[(colorFirst > 0) ? colorFirst : COLOR_BLACK];\r\n        Object(_platform__WEBPACK_IMPORTED_MODULE_1__[\"Platform_PaintPixel\"])(color.r, color.g, color.b, 0x0D * 2, 0x00 * 2, 4, _constants__WEBPACK_IMPORTED_MODULE_0__[\"ADVENTURE_TOTAL_SCREEN_HEIGHT\"]);\r\n    }\r\n    if (roomDefs[room].flags & ROOMFLAG_RIGHTTHINWALL) {\r\n        // Position missile 01 to 96,00 - right thin wall\r\n        var color = colorTable[(colorFirst > 0) ? colorLast : COLOR_BLACK];\r\n        Object(_platform__WEBPACK_IMPORTED_MODULE_1__[\"Platform_PaintPixel\"])(color.r, color.g, color.b, 0x96 * 2, 0x00 * 2, 4, _constants__WEBPACK_IMPORTED_MODULE_0__[\"ADVENTURE_TOTAL_SCREEN_HEIGHT\"]);\r\n    }\r\n}\r\nfunction DrawObject(object) {\r\n    // Get object color, size, and position\r\n    var color = object.color == COLOR_FLASH ? GetFlashColor() : colorTable[object.color];\r\n    var cx = object.x * 2;\r\n    var cy = object.y * 2;\r\n    var size = (object.size / 2) + 1;\r\n    // Look up the index to the current state for this object\r\n    var stateIndex = object.states[object.state];\r\n    // Get the height, then the data\r\n    // (the first byte of the data is the height)\r\n    var dataP = object.gfxData;\r\n    var i = 0;\r\n    var objHeight = dataP[i++];\r\n    // Index into the proper state\r\n    for (var x = 0; x < stateIndex; x++) {\r\n        i += objHeight; // skip over the data\r\n        objHeight = dataP[i++];\r\n    }\r\n    // Adjust for proper position\r\n    cx -= CLOCKS_HSYNC;\r\n    cy -= CLOCKS_VSYNC;\r\n    // scan the data\r\n    for (var j = 0; j < objHeight; j++) {\r\n        // Parse the row - each bit is a 2 x 2 block\r\n        for (var bit = 0; bit < 8; bit++) {\r\n            if (dataP[i] & (1 << (7 - bit))) {\r\n                var x = cx + (bit * 2 * size);\r\n                if (x >= _constants__WEBPACK_IMPORTED_MODULE_0__[\"ADVENTURE_SCREEN_WIDTH\"])\r\n                    x -= _constants__WEBPACK_IMPORTED_MODULE_0__[\"ADVENTURE_SCREEN_WIDTH\"];\r\n                Object(_platform__WEBPACK_IMPORTED_MODULE_1__[\"Platform_PaintPixel\"])(color.r, color.g, color.b, x, cy, 2 * size, 2);\r\n            }\r\n        }\r\n        // next byte - next row\r\n        i++;\r\n        cy -= 2;\r\n    }\r\n}\r\nfunction CollisionCheckBallWithWalls(room, x, y) {\r\n    var hitWall = false;\r\n    // The playfield is drawn partially in the overscan area, so shift that out here\r\n    y -= 30;\r\n    // get the playfield data\r\n    var currentRoom = roomDefs[room];\r\n    var roomData = currentRoom.graphicsData;\r\n    // get the playfield mirror flag\r\n    var mirror = currentRoom.flags & ROOMFLAG_MIRROR;\r\n    // mask values for playfield bits\r\n    var shiftreg = [\r\n        0x10, 0x20, 0x40, 0x80,\r\n        0x80, 0x40, 0x20, 0x10, 0x8, 0x4, 0x2, 0x1,\r\n        0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80\r\n    ];\r\n    // each cell is 8 x 32\r\n    var cell_width = 8;\r\n    var cell_height = 32;\r\n    if ((currentRoom.flags & ROOMFLAG_LEFTTHINWALL) && ((x - (4 + 4)) < 0x0D * 2)) {\r\n        hitWall = true;\r\n    }\r\n    if ((currentRoom.flags & ROOMFLAG_RIGHTTHINWALL) && ((x + 4) > 0x96 * 2)) {\r\n        // If the dot is in this room, allow passage through the wall into the Easter Egg room\r\n        if (objectDefs[OBJECT_DOT].room != room)\r\n            hitWall = true;\r\n    }\r\n    // Check each bit of the playfield data to see if they intersect the ball\r\n    for (var cy = 0; (cy <= 6) && !hitWall; cy++) {\r\n        var pf0 = roomData[(cy * 3) + 0];\r\n        var pf1 = roomData[(cy * 3) + 1];\r\n        var pf2 = roomData[(cy * 3) + 2];\r\n        var ypos = 6 - cy;\r\n        for (var cx = 0; cx < 20; cx++) {\r\n            var bit = false;\r\n            if (cx < 4)\r\n                bit = (pf0 & shiftreg[cx]) ? true : false;\r\n            else if (cx < 12)\r\n                bit = (pf1 & shiftreg[cx]) ? true : false;\r\n            else\r\n                bit = (pf2 & shiftreg[cx]) ? true : false;\r\n            if (bit) {\r\n                if (HitTestRects(x - 4, (y - 4), 8, 8, cx * cell_width, (ypos * cell_height), cell_width, cell_height)) {\r\n                    hitWall = true;\r\n                    break;\r\n                }\r\n                if (mirror) {\r\n                    if (HitTestRects(x - 4, (y - 4), 8, 8, (cx + 20) * cell_width, (ypos * cell_height), cell_width, cell_height)) {\r\n                        hitWall = true;\r\n                        break;\r\n                    }\r\n                }\r\n                else {\r\n                    if (HitTestRects(x - 4, (y - 4), 8, 8, ((40 - (cx + 1)) * cell_width), (ypos * cell_height), cell_width, cell_height)) {\r\n                        hitWall = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return hitWall;\r\n}\r\nfunction CrossingBridge(room, x, y) {\r\n    // Check going through the bridge\r\n    var bridge = objectDefs[OBJECT_BRIDGE];\r\n    if ((bridge.room == room)\r\n        && (objectBall.linkedObject != OBJECT_BRIDGE)) {\r\n        var xDiff = (x / 2) - bridge.x;\r\n        if ((xDiff >= 0x0A) && (xDiff <= 0x17)) {\r\n            var yDiff = bridge.y - (y / 2);\r\n            if ((yDiff >= -5) && (yDiff <= 0x15)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction CollisionCheckBallWithObjects(startIndex) {\r\n    // Go through all the objects\r\n    for (var i = startIndex; objectDefs[i].gfxData; i++) {\r\n        // If this object is in the current room, check it against the ball\r\n        var object = objectDefs[i];\r\n        if (object.displayed && (objectBall.room == object.room)) {\r\n            if (CollisionCheckObject(object, objectBall.x - 4, (objectBall.y - 1), 8, 8)) {\r\n                // return the index of the object\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n    return OBJECT_NONE;\r\n}\r\nfunction CalcPlayerSpriteExtents(object) {\r\n    // Calculate the object's size and position\r\n    var cx = object.x * 2;\r\n    var cy = object.y * 2;\r\n    var size = (object.size / 2) + 1;\r\n    var cw = (8 * 2) * size;\r\n    // Look up the index to the current state for this object\r\n    var stateIndex = object.states[object.state];\r\n    // Get the height, then the data\r\n    // (the first byte of the data is the height)\r\n    var dataP = object.gfxData;\r\n    var i = 0;\r\n    var ch = dataP[i++];\r\n    // Index into the proper state\r\n    for (var x = 0; x < stateIndex; x++) {\r\n        i += ch; // skip over the data\r\n        ch = dataP[i++];\r\n    }\r\n    ch *= 2;\r\n    // Adjust for proper position\r\n    cx -= CLOCKS_HSYNC;\r\n    return { x: cx, y: cy, w: cw, h: ch };\r\n}\r\n// Collision check two objects\r\n// On the 2600 this is done in hardware by the Player/Missile collision registers\r\nfunction CollisionCheckObjectObject(object1, object2) {\r\n    // Before we do pixel by pixel collision checking, do some trivial rejection\r\n    // and return early if the object extents do not even overlap or are not in the same room\r\n    if (object1.room != object2.room)\r\n        return false;\r\n    var extent1 = CalcPlayerSpriteExtents(object1);\r\n    var extent2 = CalcPlayerSpriteExtents(object2);\r\n    if (!HitTestRects(extent1.x, extent1.y, extent1.w, extent1.h, extent2.x, extent2.y, extent2.w, extent2.h))\r\n        return false;\r\n    // Object extents overlap go pixel by pixel\r\n    var objectX1 = object1.x;\r\n    var objectY1 = object1.y;\r\n    var objectSize1 = (object1.size / 2) + 1;\r\n    var objectX2 = object2.x;\r\n    var objectY2 = object2.y;\r\n    var objectSize2 = (object2.size / 2) + 1;\r\n    // Look up the index to the current state for the objects\r\n    var stateIndex1 = object1.states[object1.state];\r\n    var stateIndex2 = object2.states[object2.state];\r\n    // Get the height, then the data\r\n    // (the first byte of the data is the height)\r\n    var dataP1 = object1.gfxData;\r\n    var i1 = 0;\r\n    var objHeight1 = dataP1[i1++];\r\n    var dataP2 = object2.gfxData;\r\n    var i2 = 0;\r\n    var objHeight2 = dataP2[i2++];\r\n    // Index into the proper states\r\n    for (var i = 0; i < stateIndex1; i++) {\r\n        i1 += objHeight1; // skip over the data\r\n        objHeight1 = dataP1[i1++];\r\n    }\r\n    for (var i = 0; i < stateIndex2; i++) {\r\n        i2 += objHeight2; // skip over the data\r\n        objHeight2 = dataP2[i2++];\r\n    }\r\n    var obj2DataStartIndex = i2;\r\n    // Adjust for proper position\r\n    objectX1 -= CLOCKS_HSYNC;\r\n    objectX2 -= CLOCKS_HSYNC;\r\n    // Scan the the object1 data\r\n    for (var i = 0; i < objHeight1; i++) {\r\n        var a = [];\r\n        // Parse the object1 row - each bit is a 2 x 2 block\r\n        var rowByte1 = dataP1[i1];\r\n        for (var bit1 = 0; bit1 < 8; bit1++) {\r\n            if (rowByte1 & (1 << (7 - bit1))) {\r\n                // test this pixel of object1 for intersection against the pixels of object2\r\n                i2 = obj2DataStartIndex;\r\n                // Scan the the object2 data\r\n                for (var j = 0; j < objHeight2; j++) {\r\n                    // Parse the object2 row - each bit is a 2 x 2 block\r\n                    var rowByte2 = dataP2[i2];\r\n                    for (var bit2 = 0; bit2 < 8; bit2++) {\r\n                        if (rowByte2 & (1 << (7 - bit2))) {\r\n                            var wrappedX1 = objectX1 + (bit1 * 2 * objectSize1);\r\n                            if (wrappedX1 >= _constants__WEBPACK_IMPORTED_MODULE_0__[\"ADVENTURE_SCREEN_WIDTH\"])\r\n                                wrappedX1 -= _constants__WEBPACK_IMPORTED_MODULE_0__[\"ADVENTURE_SCREEN_WIDTH\"];\r\n                            var wrappedX2 = objectX2 + (bit2 * 2 * objectSize2);\r\n                            if (wrappedX2 >= _constants__WEBPACK_IMPORTED_MODULE_0__[\"ADVENTURE_SCREEN_WIDTH\"])\r\n                                wrappedX2 -= _constants__WEBPACK_IMPORTED_MODULE_0__[\"ADVENTURE_SCREEN_WIDTH\"];\r\n                            if (HitTestRects(wrappedX1, objectY1, 2 * objectSize1, 2, wrappedX2, objectY2, 2 * objectSize2, 2)) {\r\n                                // The objects are touching\r\n                                return true;\r\n                            }\r\n                        }\r\n                    }\r\n                    // Object 2 - next byte and next row\r\n                    ++i2;\r\n                    objectY2 += 2;\r\n                }\r\n            }\r\n        }\r\n        // Object 1 - next byte and next row\r\n        ++i1;\r\n        objectY1 += 2;\r\n    }\r\n    return false;\r\n}\r\n// Checks an object for collision against the specified rectangle\r\n// On the 2600 this is done in hardware by the Player/Missile collision registers\r\nfunction CollisionCheckObject(object, x, y, width, height) {\r\n    var objectX = object.x * 2;\r\n    var objectY = object.y * 2;\r\n    var objectSize = (object.size / 2) + 1;\r\n    // Look up the index to the current state for this object\r\n    var stateIndex = object.states[object.state];\r\n    // Get the height, then the data\r\n    // (the first byte of the data is the height)\r\n    var dataP = object.gfxData;\r\n    var i = 0;\r\n    var objHeight = dataP[i++];\r\n    // Index into the proper state\r\n    for (var j = 0; j < stateIndex; j++) {\r\n        i += objHeight; // skip over the data\r\n        objHeight = dataP[i++];\r\n    }\r\n    // Adjust for proper position\r\n    objectX -= CLOCKS_HSYNC;\r\n    // scan the data\r\n    for (var j = 0; j < objHeight; j++) {\r\n        // Parse the row - each bit is a 2 x 2 block\r\n        var rowByte = dataP[i];\r\n        for (var bit = 0; bit < 8; bit++) {\r\n            if (rowByte & (1 << (7 - bit))) {\r\n                // test this pixel for intersection\r\n                var wrappedX = objectX + (bit * 2 * objectSize);\r\n                if (wrappedX >= _constants__WEBPACK_IMPORTED_MODULE_0__[\"ADVENTURE_SCREEN_WIDTH\"])\r\n                    wrappedX -= _constants__WEBPACK_IMPORTED_MODULE_0__[\"ADVENTURE_SCREEN_WIDTH\"];\r\n                if (HitTestRects(x, y, width, height, wrappedX, objectY, 2 * objectSize, 2)) {\r\n                    // The objects are touching\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        // next byte - next row\r\n        ++i;\r\n        objectY -= 2;\r\n    }\r\n    return false;\r\n}\r\nfunction HitTestRects(ax, ay, awidth, aheight, bx, by, bwidth, bheight) {\r\n    var intersects = true;\r\n    if (((ay - aheight) >= by) || (ay <= (by - bheight)) || ((ax + awidth) <= bx) || (ax >= (bx + bwidth))) {\r\n        // Does not intersect\r\n        intersects = false;\r\n    }\r\n    // else must intersect\r\n    return intersects;\r\n}\r\nfunction GetFlashColor() {\r\n    var r = 0, g = 0, b = 0;\r\n    var h = flashColorHue / (360.0 / 3);\r\n    if (h < 1) {\r\n        r = h * 255;\r\n        g = 0;\r\n        b = (1 - h) * 255;\r\n    }\r\n    else if (h < 2) {\r\n        h -= 1;\r\n        r = (1 - h) * 255;\r\n        g = h * 255;\r\n        b = 0;\r\n    }\r\n    else {\r\n        h -= 2;\r\n        r = 0;\r\n        g = (1 - h) * 255;\r\n        b = h * 255;\r\n    }\r\n    var color = {\r\n        r: Math.max(flashColorLum, r),\r\n        g: Math.max(flashColorLum, g),\r\n        b: Math.max(flashColorLum, b)\r\n    };\r\n    return color;\r\n}\r\nfunction AdvanceFlashColor() {\r\n    flashColorHue += 2;\r\n    if (flashColorHue >= 360)\r\n        flashColorHue -= 360;\r\n    flashColorLum += 11;\r\n    if (flashColorLum > 200)\r\n        flashColorLum = 0;\r\n}\r\n\n\n//# sourceURL=webpack:///./src/adventure.ts?");

/***/ }),

/***/ "./src/constants.ts":
/*!**************************!*\
  !*** ./src/constants.ts ***!
  \**************************/
/*! exports provided: ADVENTURE_SCREEN_WIDTH, ADVENTURE_SCREEN_HEIGHT, ADVENTURE_OVERSCAN, ADVENTURE_TOTAL_SCREEN_HEIGHT, ADVENTURE_FPS, DIFFICULTY_A, DIFFICULTY_B, SOUND_WON, SOUND_ROAR, SOUND_EATEN, SOUND_DRAGONDIE, SOUND_PUTDOWN, SOUND_PICKUP */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ADVENTURE_SCREEN_WIDTH\", function() { return ADVENTURE_SCREEN_WIDTH; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ADVENTURE_SCREEN_HEIGHT\", function() { return ADVENTURE_SCREEN_HEIGHT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ADVENTURE_OVERSCAN\", function() { return ADVENTURE_OVERSCAN; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ADVENTURE_TOTAL_SCREEN_HEIGHT\", function() { return ADVENTURE_TOTAL_SCREEN_HEIGHT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ADVENTURE_FPS\", function() { return ADVENTURE_FPS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DIFFICULTY_A\", function() { return DIFFICULTY_A; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DIFFICULTY_B\", function() { return DIFFICULTY_B; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SOUND_WON\", function() { return SOUND_WON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SOUND_ROAR\", function() { return SOUND_ROAR; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SOUND_EATEN\", function() { return SOUND_EATEN; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SOUND_DRAGONDIE\", function() { return SOUND_DRAGONDIE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SOUND_PUTDOWN\", function() { return SOUND_PUTDOWN; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SOUND_PICKUP\", function() { return SOUND_PICKUP; });\n// sizes\r\nvar ADVENTURE_SCREEN_WIDTH = 320;\r\nvar ADVENTURE_SCREEN_HEIGHT = 192;\r\nvar ADVENTURE_OVERSCAN = 16;\r\nvar ADVENTURE_TOTAL_SCREEN_HEIGHT = (ADVENTURE_SCREEN_HEIGHT + ADVENTURE_OVERSCAN + ADVENTURE_OVERSCAN);\r\nvar ADVENTURE_FPS = 58;\r\n// Difficulty switch values\r\nvar DIFFICULTY_A = 0;\r\nvar DIFFICULTY_B = 1;\r\n// The sounds\r\nvar SOUND_WON = 0;\r\nvar SOUND_ROAR = 1;\r\nvar SOUND_EATEN = 2;\r\nvar SOUND_DRAGONDIE = 3;\r\nvar SOUND_PUTDOWN = 4;\r\nvar SOUND_PICKUP = 5;\r\n\n\n//# sourceURL=webpack:///./src/constants.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _platform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./platform */ \"./src/platform.ts\");\n\r\ndocument.addEventListener('DOMContentLoaded', function () {\r\n    Object(_platform__WEBPACK_IMPORTED_MODULE_0__[\"start\"])();\r\n}, false);\r\n\n\n//# sourceURL=webpack:///./src/index.ts?");

/***/ }),

/***/ "./src/platform.ts":
/*!*************************!*\
  !*** ./src/platform.ts ***!
  \*************************/
/*! exports provided: start, Platform_PaintPixel, Platform_ReadJoystick, Platform_ReadSelectSwitch, Platform_ReadResetSwitch, Platform_ReadDifficultySwitches, Platform_MakeSound, Platform_Random */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"start\", function() { return start; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Platform_PaintPixel\", function() { return Platform_PaintPixel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Platform_ReadJoystick\", function() { return Platform_ReadJoystick; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Platform_ReadSelectSwitch\", function() { return Platform_ReadSelectSwitch; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Platform_ReadResetSwitch\", function() { return Platform_ReadResetSwitch; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Platform_ReadDifficultySwitches\", function() { return Platform_ReadDifficultySwitches; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Platform_MakeSound\", function() { return Platform_MakeSound; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Platform_Random\", function() { return Platform_Random; });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/constants.ts\");\n/* harmony import */ var _adventure__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./adventure */ \"./src/adventure.ts\");\n\r\n\r\nvar canvas;\r\nvar ctx;\r\nvar keyReset = false;\r\nvar keySelect = false;\r\nvar keyLeft = false;\r\nvar keyRight = false;\r\nvar keyUp = false;\r\nvar keyDown = false;\r\nvar keyFire = false;\r\nvar soundPickup;\r\nvar soundPutdown;\r\nvar soundRoar;\r\nvar soundDragonDie;\r\nvar soundEaten;\r\nvar soundWon;\r\nfunction start() {\r\n    // Set up the sounds\r\n    soundPickup = new Audio('./sounds/pickup.wav');\r\n    soundPutdown = new Audio('./sounds/putdown.wav');\r\n    soundRoar = new Audio('./sounds/roar.wav');\r\n    soundDragonDie = new Audio('./sounds/dragondie.wav');\r\n    soundEaten = new Audio('./sounds/eaten.wav');\r\n    soundWon = new Audio('./sounds/won.wav');\r\n    // preload the sounds\r\n    soundPickup.addEventListener('loadeddata', function () { });\r\n    soundPutdown.addEventListener('loadeddata', function () { });\r\n    soundRoar.addEventListener('loadeddata', function () { });\r\n    soundDragonDie.addEventListener('loadeddata', function () { });\r\n    soundEaten.addEventListener('loadeddata', function () { });\r\n    soundWon.addEventListener('loadeddata', function () { });\r\n    // Set up the canvas for drawing\r\n    canvas = document.getElementById(\"canvas\");\r\n    ctx = canvas.getContext(\"2d\");\r\n    ctx.imageSmoothingEnabled = false;\r\n    // The game expects a bottom up buffer, so we flip the orientation here\r\n    ctx.transform(1, 0, 0, -1, 0, canvas.height);\r\n    // Watch for keypresses\r\n    var keyCodeUp = 38;\r\n    var keyCodeDown = 40;\r\n    var keyCodeLeft = 37;\r\n    var keyCodeRight = 39;\r\n    var keyCodeSpace = 32;\r\n    window.onkeydown = function (e) {\r\n        switch (e.key) {\r\n            case '1':\r\n                keyReset = true;\r\n                break;\r\n            case '2':\r\n                keySelect = true;\r\n                break;\r\n        }\r\n        switch (e.keyCode) {\r\n            case keyCodeUp:\r\n                keyUp = true;\r\n                break;\r\n            case keyCodeDown:\r\n                keyDown = true;\r\n                break;\r\n            case keyCodeLeft:\r\n                keyLeft = true;\r\n                break;\r\n            case keyCodeRight:\r\n                keyRight = true;\r\n                break;\r\n            case keyCodeSpace:\r\n                keyFire = true;\r\n                break;\r\n        }\r\n    };\r\n    window.onkeyup = function (e) {\r\n        switch (e.key) {\r\n            case '1':\r\n                keyReset = false;\r\n                break;\r\n            case '2':\r\n                keySelect = false;\r\n                break;\r\n        }\r\n        switch (e.keyCode) {\r\n            case keyCodeUp:\r\n                keyUp = false;\r\n                break;\r\n            case keyCodeDown:\r\n                keyDown = false;\r\n                break;\r\n            case keyCodeLeft:\r\n                keyLeft = false;\r\n                break;\r\n            case keyCodeRight:\r\n                keyRight = false;\r\n                break;\r\n            case keyCodeSpace:\r\n                keyFire = false;\r\n                break;\r\n        }\r\n    };\r\n    setInterval(function () {\r\n        Object(_adventure__WEBPACK_IMPORTED_MODULE_1__[\"Adventure_Run\"])();\r\n    }, 1000 / _constants__WEBPACK_IMPORTED_MODULE_0__[\"ADVENTURE_FPS\"]);\r\n}\r\n// These are called from the game code\r\nfunction Platform_PaintPixel(r, g, b, x, y, width, height) {\r\n    width = width ? width : 1;\r\n    height = height ? height : 1;\r\n    y -= _constants__WEBPACK_IMPORTED_MODULE_0__[\"ADVENTURE_OVERSCAN\"];\r\n    ctx.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',1)';\r\n    ctx.fillRect(x, y, width, height);\r\n}\r\nfunction Platform_ReadJoystick(joystick) {\r\n    joystick.left = keyLeft;\r\n    joystick.up = keyUp;\r\n    joystick.right = keyRight;\r\n    joystick.down = keyDown;\r\n    joystick.fire = keyFire;\r\n}\r\nfunction Platform_ReadSelectSwitch() {\r\n    return keySelect;\r\n}\r\nfunction Platform_ReadResetSwitch() {\r\n    return keyReset;\r\n}\r\nfunction Platform_ReadDifficultySwitches() {\r\n    return {\r\n        left: 1,\r\n        right: 0\r\n    };\r\n}\r\nfunction Platform_MakeSound(sound) {\r\n    switch (sound) {\r\n        case _constants__WEBPACK_IMPORTED_MODULE_0__[\"SOUND_PICKUP\"]:\r\n            soundPickup.play();\r\n            break;\r\n        case _constants__WEBPACK_IMPORTED_MODULE_0__[\"SOUND_PUTDOWN\"]:\r\n            soundPutdown.play();\r\n            break;\r\n        case _constants__WEBPACK_IMPORTED_MODULE_0__[\"SOUND_ROAR\"]:\r\n            soundRoar.play();\r\n            break;\r\n        case _constants__WEBPACK_IMPORTED_MODULE_0__[\"SOUND_DRAGONDIE\"]:\r\n            soundDragonDie.play();\r\n            break;\r\n        case _constants__WEBPACK_IMPORTED_MODULE_0__[\"SOUND_EATEN\"]:\r\n            soundEaten.play();\r\n            break;\r\n        case _constants__WEBPACK_IMPORTED_MODULE_0__[\"SOUND_WON\"]:\r\n            soundWon.play();\r\n            break;\r\n    }\r\n}\r\nfunction Platform_Random() {\r\n    return Math.random();\r\n}\r\n\n\n//# sourceURL=webpack:///./src/platform.ts?");

/***/ })

/******/ });